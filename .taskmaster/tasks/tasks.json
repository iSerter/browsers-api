{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Update ArtifactType enum to include SNAPSHOT type",
        "description": "Add a new SNAPSHOT type to the ArtifactType enum in the job-artifact entity to support snapshot artifact functionality as the foundation for the snapshot feature.",
        "details": "1. Locate the file src/modules/jobs/entities/job-artifact.entity.ts\n2. Find the ArtifactType enum definition\n3. Add a new enum value 'SNAPSHOT' to the existing ArtifactType enum\n4. Ensure the enum value follows the naming convention of other artifact types (e.g., uppercase)\n5. Position the new SNAPSHOT type logically within the enum (typically at the end or grouped with related types)\n6. Verify that the enum is properly exported if it's used in other modules\n7. Check if there are any type guards or validation functions that reference ArtifactType and may need updating\n8. Review any existing switch statements or conditional logic that handle ArtifactType to ensure they won't break with the new type (add default cases if needed)\n9. Update any TypeScript type definitions or interfaces that may be affected by this change",
        "testStrategy": "1. Verify the SNAPSHOT enum value is added correctly by importing ArtifactType in a test file and checking it exists\n2. Compile the TypeScript code to ensure no type errors are introduced\n3. Run existing unit tests for the job-artifact entity to ensure backward compatibility\n4. Create a simple test that instantiates or references ArtifactType.SNAPSHOT to confirm it's accessible\n5. Check that the enum can be used in type annotations and assignments without errors\n6. Verify that any ORM queries or database operations that use ArtifactType still function correctly\n7. Review the compiled JavaScript output to ensure the enum value is properly transpiled",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Update ActionType enum to include SNAPSHOT action type",
        "description": "Add a new SNAPSHOT action type to the ActionType enum in the action-config DTO to enable snapshot operations within the job action configuration system.",
        "details": "1. Navigate to the file src/modules/jobs/dto/action-config.dto.ts\n2. Locate the ActionType enum definition within the file\n3. Add a new enum value 'SNAPSHOT' to the existing ActionType enum, following the established naming convention (uppercase)\n4. Position the SNAPSHOT type appropriately within the enum - consider grouping it with related action types or placing it at the end\n5. Ensure the enum maintains consistent formatting with existing values\n6. Verify that the ActionType enum is properly exported for use in other modules\n7. Check if the enum is used in any type guards, validators, or switch statements that may need updating\n8. Review any associated validation decorators or pipes that reference ActionType to ensure they will accept the new value\n9. Document the purpose of the SNAPSHOT action type with a comment if the enum includes documentation\n10. Ensure consistency with the ArtifactType.SNAPSHOT addition from Task 1",
        "testStrategy": "1. Verify the SNAPSHOT enum value exists by importing ActionType and checking that ActionType.SNAPSHOT is defined\n2. Compile the TypeScript code to confirm no type errors are introduced\n3. Run existing unit tests for DTOs and action configuration to ensure backward compatibility\n4. Create a test that instantiates an action config object with ActionType.SNAPSHOT to verify it's accepted by validation\n5. If class-validator decorators are present, test that SNAPSHOT passes validation rules\n6. Verify that any existing switch statements or type guards handle the new enum value appropriately (or add TODO comments where updates are needed)\n7. Check that the enum can be serialized and deserialized correctly in API requests",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Add snapshot configuration fields to ActionConfigDto with validation decorators",
        "description": "Extend the ActionConfigDto class to include configuration fields for snapshot operations (cookies, localStorage, sessionStorage) with proper validation decorators to ensure data integrity and type safety.",
        "details": "1. Open the file src/modules/jobs/dto/action-config.dto.ts\n2. Import necessary validation decorators from class-validator: @IsOptional, @IsBoolean, @ValidateNested, @IsObject, @IsArray, @IsString\n3. Import Type from class-transformer for nested object validation\n4. Add a new nested DTO class 'SnapshotConfigDto' before the ActionConfigDto class:\n   - Add @IsOptional() @IsBoolean() cookies?: boolean field to control cookie capture\n   - Add @IsOptional() @IsBoolean() localStorage?: boolean field to control localStorage capture\n   - Add @IsOptional() @IsBoolean() sessionStorage?: boolean field to control sessionStorage capture\n5. In the ActionConfigDto class, add a new property for snapshot configuration:\n   - Add @IsOptional() @ValidateNested() @Type(() => SnapshotConfigDto) snapshotConfig?: SnapshotConfigDto\n6. Ensure the snapshotConfig field is only relevant when actionType is SNAPSHOT by adding conditional validation logic or documentation\n7. Add JSDoc comments explaining the purpose of each field and the SnapshotConfigDto class\n8. Verify that all imports are properly organized at the top of the file\n9. Ensure consistent code formatting with the rest of the file (indentation, spacing)\n10. Consider adding default values documentation for when fields are omitted",
        "testStrategy": "1. Create unit tests for SnapshotConfigDto validation:\n   - Test that all fields accept boolean values when provided\n   - Test that all fields are optional and can be omitted\n   - Test that invalid types (strings, numbers) are rejected with appropriate validation errors\n2. Create unit tests for ActionConfigDto with snapshotConfig:\n   - Test that snapshotConfig accepts a valid SnapshotConfigDto object\n   - Test that snapshotConfig is optional and can be null/undefined\n   - Test that nested validation works correctly (invalid nested objects are rejected)\n3. Integration test: Create a complete ActionConfigDto with actionType SNAPSHOT and valid snapshotConfig, validate it passes\n4. Integration test: Create ActionConfigDto with invalid snapshotConfig values and verify validation fails with descriptive error messages\n5. Compile TypeScript to ensure no type errors\n6. Run all existing DTO tests to ensure backward compatibility\n7. Verify that the validation decorators work correctly by instantiating the DTO with various valid and invalid payloads",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create SnapshotActionHandler class with execute method for capturing browser state",
        "description": "Implement the SnapshotActionHandler class that captures HTML content, metadata, and conditionally captures cookies, localStorage, and sessionStorage based on configuration, then packages the data as JSON and saves it as an artifact.",
        "details": "1. Create a new file src/modules/jobs/handlers/snapshot-action.handler.ts\n2. Import necessary dependencies: Injectable decorator from @nestjs/common, ActionType from action-config.dto, ArtifactType from job-artifact.entity, SnapshotConfigDto from action-config.dto\n3. Import Puppeteer types (Page) and any required services (JobArtifactService, Logger)\n4. Define the SnapshotActionHandler class with @Injectable() decorator\n5. Implement constructor to inject required services (JobArtifactService, Logger)\n6. Create the execute method with signature: async execute(page: Page, config: SnapshotConfigDto, jobId: string): Promise<void>\n7. Inside execute method:\n   a. Capture HTML content using page.content() - this is always captured\n   b. Capture metadata including URL (page.url()), title (page.title()), timestamp (new Date().toISOString()), viewport dimensions\n   c. Conditionally capture cookies using page.cookies() if config.cookies is true\n   d. Conditionally capture localStorage by evaluating page.evaluate(() => JSON.stringify(localStorage)) if config.localStorage is true\n   e. Conditionally capture sessionStorage by evaluating page.evaluate(() => JSON.stringify(sessionStorage)) if config.sessionStorage is true\n8. Package all captured data into a structured JSON object with properties: html, metadata, cookies (optional), localStorage (optional), sessionStorage (optional)\n9. Convert the JSON object to a string using JSON.stringify()\n10. Call JobArtifactService to save the artifact with type ArtifactType.SNAPSHOT, including jobId, data, and appropriate metadata\n11. Add error handling with try-catch blocks and appropriate logging\n12. Add JSDoc comments documenting the class, method parameters, and return values",
        "testStrategy": "1. Create unit tests in snapshot-action.handler.spec.ts:\n   a. Mock Puppeteer Page object with methods: content(), url(), title(), cookies(), evaluate()\n   b. Mock JobArtifactService with save method\n   c. Test execute method captures HTML content correctly\n   d. Test execute method captures metadata (URL, title, timestamp)\n   e. Test conditional cookie capture when config.cookies is true/false\n   f. Test conditional localStorage capture when config.localStorage is true/false\n   g. Test conditional sessionStorage capture when config.sessionStorage is true/false\n   h. Test that all captured data is properly packaged into JSON structure\n   i. Test that JobArtifactService.save is called with correct parameters (jobId, ArtifactType.SNAPSHOT, JSON data)\n   j. Test error handling when page methods throw errors\n   k. Test that logger is called appropriately for errors and success\n2. Create integration tests:\n   a. Test with real Puppeteer page instance on a test HTML page\n   b. Verify captured HTML matches expected content\n   c. Verify captured cookies, localStorage, and sessionStorage match test data\n   d. Verify saved artifact can be retrieved and parsed correctly\n3. Test edge cases: empty localStorage/sessionStorage, pages with no cookies, pages with special characters in HTML",
        "status": "done",
        "dependencies": [
          1,
          3
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Register SnapshotActionHandler in ActionHandlerFactory constructor",
        "description": "Update the ActionHandlerFactory to instantiate and register the SnapshotActionHandler, mapping it to the SNAPSHOT action type so the factory can properly route snapshot actions to the appropriate handler.",
        "details": "1. Open the file src/modules/jobs/factories/action-handler.factory.ts\n2. Import the SnapshotActionHandler class from '../handlers/snapshot-action.handler'\n3. Import ActionType enum from '../dto/action-config.dto' if not already imported\n4. Locate the ActionHandlerFactory class constructor\n5. Inject SnapshotActionHandler as a dependency in the constructor parameters (e.g., private readonly snapshotActionHandler: SnapshotActionHandler)\n6. Within the constructor body, find where action handlers are registered to the internal handler map/registry\n7. Add a new registration entry mapping ActionType.SNAPSHOT to the snapshotActionHandler instance\n8. Follow the existing pattern used for other action handlers (e.g., this.handlers.set(ActionType.SNAPSHOT, this.snapshotActionHandler) or similar based on the factory's implementation)\n9. Ensure the registration maintains consistency with other handler registrations in terms of formatting and structure\n10. Verify that the ActionHandlerFactory module properly provides SnapshotActionHandler in its module dependencies\n11. Check if any additional configuration or initialization is needed for the handler registration",
        "testStrategy": "1. Create unit tests in action-handler.factory.spec.ts:\n   a. Mock SnapshotActionHandler and verify it's injected into the factory constructor\n   b. Test that getHandler(ActionType.SNAPSHOT) returns the SnapshotActionHandler instance\n   c. Verify the handler is properly registered in the factory's internal map\n2. Create integration tests:\n   a. Instantiate ActionHandlerFactory with all dependencies including SnapshotActionHandler\n   b. Request a handler for ActionType.SNAPSHOT and verify it returns the correct handler type\n   c. Test that the returned handler has the expected execute method\n3. Test backward compatibility:\n   a. Verify existing action type registrations still work correctly\n   b. Ensure no existing handler registrations are affected by the new addition\n4. Test error handling:\n   a. Verify appropriate behavior if SnapshotActionHandler fails to inject\n5. Run the full test suite to ensure no regressions in the factory or related modules",
        "status": "done",
        "dependencies": [
          2,
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Register SnapshotActionHandler as a provider in JobsModule",
        "description": "Update the JobsModule to include SnapshotActionHandler in the providers array, ensuring it's available for dependency injection throughout the jobs module and can be properly instantiated by the ActionHandlerFactory.",
        "details": "1. Open the file src/modules/jobs/jobs.module.ts\n2. Import the SnapshotActionHandler class from './handlers/snapshot-action.handler'\n3. Locate the @Module decorator and find the 'providers' array\n4. Add SnapshotActionHandler to the providers array, maintaining alphabetical order or grouping it with other action handlers\n5. Verify that any services required by SnapshotActionHandler (such as JobArtifactService) are also registered as providers in the module\n6. If JobsModule exports providers, consider whether SnapshotActionHandler should be added to the 'exports' array (typically not needed if only used internally)\n7. Ensure the module imports any necessary modules that SnapshotActionHandler depends on (e.g., if it uses services from other modules)\n8. Check that the ActionHandlerFactory is also in the providers array so it can inject SnapshotActionHandler\n9. Verify the module structure follows NestJS best practices for provider registration\n10. Save the file and ensure no circular dependency issues are introduced",
        "testStrategy": "1. Verify the module compiles without errors after adding the provider\n2. Create an integration test that bootstraps the JobsModule and verifies SnapshotActionHandler can be resolved from the dependency injection container\n3. Test that ActionHandlerFactory can successfully inject and use SnapshotActionHandler\n4. Run the NestJS application in development mode and check for any module initialization errors in the logs\n5. Use NestJS testing utilities to create a test module and verify SnapshotActionHandler is properly instantiated with all its dependencies\n6. Verify that calling getHandler(ActionType.SNAPSHOT) from ActionHandlerFactory returns a valid SnapshotActionHandler instance\n7. Run all existing JobsModule tests to ensure no regressions were introduced\n8. Check that the module's dependency graph is correct using NestJS CLI or debugging tools",
        "status": "done",
        "dependencies": [
          4,
          5
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create comprehensive unit tests for SnapshotActionHandler",
        "description": "Develop a complete test suite for the SnapshotActionHandler class in src/modules/jobs/handlers/snapshot-action.handler.spec.ts, covering all configuration combinations, error handling scenarios, metadata capture functionality, and artifact creation, targeting over 80% code coverage.",
        "details": "1. Create the test file src/modules/jobs/handlers/snapshot-action.handler.spec.ts\n2. Import testing utilities: Test, TestingModule from @nestjs/testing, mock utilities from jest\n3. Import the SnapshotActionHandler class and all its dependencies (JobArtifactService, Logger, ActionType, ArtifactType, SnapshotConfigDto)\n4. Set up test suite with beforeEach hook to create a testing module with mocked dependencies:\n   - Mock JobArtifactService with jest.fn() for save method\n   - Mock Logger with jest.fn() for log, error, warn methods\n   - Mock Puppeteer Page object with all required methods: content(), url(), title(), cookies(), evaluate()\n5. Create test cases for basic functionality:\n   - Test that execute method is defined and callable\n   - Test HTML content capture using page.content()\n   - Test URL capture using page.url()\n   - Test page title capture using page.title()\n6. Create test cases for configuration combinations:\n   - Test with cookies enabled (cookies: true) - verify page.cookies() is called\n   - Test with cookies disabled (cookies: false) - verify page.cookies() is not called\n   - Test with localStorage enabled (localStorage: true) - verify page.evaluate() is called with localStorage access\n   - Test with localStorage disabled (localStorage: false) - verify localStorage is not captured\n   - Test with sessionStorage enabled (sessionStorage: true) - verify page.evaluate() is called with sessionStorage access\n   - Test with sessionStorage disabled (sessionStorage: false) - verify sessionStorage is not captured\n   - Test with all options enabled simultaneously\n   - Test with all options disabled\n   - Test with mixed configurations (e.g., cookies and localStorage enabled, sessionStorage disabled)\n7. Create test cases for error handling:\n   - Test behavior when page.content() throws an error\n   - Test behavior when page.cookies() throws an error\n   - Test behavior when page.evaluate() throws an error for localStorage/sessionStorage\n   - Test behavior when JobArtifactService.save() fails\n   - Test handling of null or undefined page object\n   - Test handling of invalid configuration objects\n8. Create test cases for metadata capture:\n   - Verify timestamp is captured and formatted correctly\n   - Verify user agent is captured from page context\n   - Verify viewport dimensions are captured\n   - Verify all metadata fields are included in the final artifact\n9. Create test cases for artifact creation:\n   - Verify JobArtifactService.save() is called with correct parameters\n   - Verify artifact type is set to ArtifactType.SNAPSHOT\n   - Verify artifact data is properly formatted as JSON\n   - Verify artifact includes all captured data (HTML, metadata, optional storage data)\n   - Verify artifact filename follows expected naming convention\n10. Add integration-style tests:\n    - Test complete execution flow from start to finish\n    - Verify the handler returns expected result structure\n11. Use code coverage tools (jest --coverage) to measure coverage and identify untested code paths\n12. Add edge case tests for boundary conditions and unusual inputs",
        "testStrategy": "1. Run the test suite with jest and verify all tests pass: npm test snapshot-action.handler.spec.ts\n2. Generate code coverage report: npm test -- --coverage snapshot-action.handler.spec.ts\n3. Verify code coverage exceeds 80% threshold for:\n   - Statement coverage\n   - Branch coverage\n   - Function coverage\n   - Line coverage\n4. Review coverage report to identify any untested code paths and add additional tests if needed\n5. Verify all mocks are properly configured and called with expected arguments using jest assertions:\n   - expect(mockService.method).toHaveBeenCalledWith(expectedArgs)\n   - expect(mockService.method).toHaveBeenCalledTimes(expectedCount)\n6. Test that error scenarios properly throw or handle exceptions\n7. Verify test isolation - each test should be independent and not affect others\n8. Run tests multiple times to ensure consistency and no flaky tests\n9. Verify that all configuration combinations are tested with appropriate assertions\n10. Check that test descriptions clearly indicate what is being tested\n11. Ensure tests follow AAA pattern (Arrange, Act, Assert) for clarity\n12. Validate that async operations are properly handled with async/await or done callbacks",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create comprehensive integration tests for snapshot action in test/snapshot-action.e2e-spec.ts",
        "description": "Develop end-to-end integration tests for the snapshot action functionality, covering single and multiple snapshots, artifact creation and retrieval, all optional configuration features (cookies, localStorage, sessionStorage), and snapshots captured after page interactions.",
        "details": "1. Create the test file test/snapshot-action.e2e-spec.ts in the test directory\n2. Import necessary testing utilities: Test, TestingModule from @nestjs/testing, INestApplication from @nestjs/common\n3. Import required modules and services: AppModule, JobsService, JobArtifactService, ActionType, ArtifactType\n4. Import supertest for HTTP request testing and puppeteer types if needed for validation\n5. Set up test suite with beforeAll hook to:\n   - Create a testing module using Test.createTestingModule with AppModule\n   - Compile the module and create the NestJS application instance\n   - Initialize the application with app.init()\n   - Set up test database connection or use in-memory database\n6. Set up afterAll hook to close the application and clean up resources\n7. Implement test case: 'should create a single snapshot with HTML content and metadata'\n   - Create a job with a single snapshot action using POST /jobs endpoint\n   - Execute the job and wait for completion\n   - Retrieve the job artifacts using GET /jobs/:id/artifacts\n   - Verify artifact type is SNAPSHOT\n   - Parse the artifact content JSON and validate it contains: html, url, title, timestamp fields\n   - Verify HTML content is not empty and contains expected structure\n8. Implement test case: 'should create multiple snapshots in sequence'\n   - Create a job with multiple snapshot actions (2-3 snapshots)\n   - Execute the job and verify all snapshots are created\n   - Retrieve all artifacts and verify count matches expected number\n   - Verify each artifact has unique content and proper sequencing\n9. Implement test case: 'should capture cookies when cookies option is enabled'\n   - Create a job with snapshot action where config.snapshot.cookies = true\n   - Set up a test page with cookies using a navigate action first\n   - Execute snapshot action\n   - Retrieve artifact and verify the JSON contains a 'cookies' array with cookie data\n   - Validate cookie structure includes name, value, domain fields\n10. Implement test case: 'should not capture cookies when cookies option is disabled or omitted'\n    - Create job with snapshot action where config.snapshot.cookies = false or undefined\n    - Execute the job\n    - Verify artifact JSON does not contain 'cookies' field or it's null/empty\n11. Implement test case: 'should capture localStorage when localStorage option is enabled'\n    - Create job with navigate action to set localStorage items, then snapshot with config.snapshot.localStorage = true\n    - Execute the job\n    - Verify artifact contains 'localStorage' object with key-value pairs\n12. Implement test case: 'should capture sessionStorage when sessionStorage option is enabled'\n    - Create job with navigate action to set sessionStorage items, then snapshot with config.snapshot.sessionStorage = true\n    - Execute the job\n    - Verify artifact contains 'sessionStorage' object with key-value pairs\n13. Implement test case: 'should capture all storage types when all options are enabled'\n    - Create job with snapshot action where all options (cookies, localStorage, sessionStorage) are true\n    - Set up test page with all storage types populated\n    - Verify artifact contains all three storage types with correct data\n14. Implement test case: 'should capture snapshot after page interactions'\n    - Create job with sequence: navigate -> click action -> type action -> snapshot\n    - Execute job and verify snapshot captures the modified page state\n    - Verify HTML content reflects the interactions (e.g., form filled, elements clicked)\n15. Implement test case: 'should retrieve snapshot artifacts by job ID'\n    - Create and execute a job with snapshot actions\n    - Use GET /jobs/:id/artifacts endpoint to retrieve artifacts\n    - Filter artifacts by type SNAPSHOT\n    - Verify all snapshot artifacts are returned with correct metadata\n16. Add helper functions for common operations:\n    - createJobWithSnapshot(config): creates a job with snapshot action\n    - executeAndWaitForJob(jobId): executes job and polls until completion\n    - getSnapshotArtifacts(jobId): retrieves and filters snapshot artifacts\n    - parseSnapshotContent(artifact): parses JSON content from artifact\n17. Add cleanup in afterEach hook to delete test jobs and artifacts",
        "testStrategy": "1. Run the e2e test suite with npm run test:e2e snapshot-action.e2e-spec.ts and verify all tests pass\n2. Verify test coverage for integration scenarios:\n   - Single snapshot creation and retrieval\n   - Multiple snapshots in one job\n   - Each optional feature (cookies, localStorage, sessionStorage) individually\n   - All optional features combined\n   - Snapshots after page interactions\n3. Test with real browser instance (Chromium via Puppeteer) to ensure actual browser state capture works\n4. Verify artifacts are properly stored in the database and retrievable via API\n5. Test error scenarios:\n   - Invalid snapshot configuration\n   - Snapshot on non-existent page\n   - Snapshot before navigation\n6. Validate JSON structure of snapshot artifacts matches expected schema\n7. Verify timestamps are accurate and metadata is complete\n8. Test artifact cleanup and deletion\n9. Run tests in CI/CD pipeline to ensure consistency across environments\n10. Verify no memory leaks or resource issues when creating multiple snapshots\n11. Test concurrent snapshot operations if applicable\n12. Validate that snapshot content is properly escaped and sanitized in JSON format",
        "status": "done",
        "dependencies": [
          4,
          5,
          6,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Update README.md to add snapshot action to available actions list and include usage examples with configuration options",
        "description": "Update the project's README.md documentation to include the new SNAPSHOT action type in the available actions list and provide comprehensive usage examples demonstrating all configuration options including cookies, localStorage, and sessionStorage capture.",
        "details": "1. Open the README.md file in the project root directory\n2. Locate the section that lists available action types (likely under 'Available Actions', 'Action Types', or 'Features' heading)\n3. Add SNAPSHOT to the list of action types with a brief description: 'SNAPSHOT - Captures the current state of a web page including HTML content, metadata, and optionally cookies, localStorage, and sessionStorage'\n4. Create or locate the 'Usage Examples' or 'Configuration' section\n5. Add a new subsection titled 'Snapshot Action' or 'Taking Page Snapshots'\n6. Include a basic example showing minimal snapshot configuration:\n   ```json\n   {\n     \"type\": \"SNAPSHOT\"\n   }\n   ```\n7. Add an advanced example demonstrating all optional configuration fields:\n   ```json\n   {\n     \"type\": \"SNAPSHOT\",\n     \"snapshot\": {\n       \"cookies\": true,\n       \"localStorage\": true,\n       \"sessionStorage\": true\n     }\n   }\n   ```\n8. Document what data is captured by default (HTML content, URL, title, timestamp)\n9. Explain each optional configuration field:\n   - cookies: When true, captures all browser cookies for the current domain\n   - localStorage: When true, captures all localStorage key-value pairs\n   - sessionStorage: When true, captures all sessionStorage key-value pairs\n10. Add a note about artifact storage: 'Snapshot data is saved as a JSON artifact that can be retrieved via the artifacts API endpoint'\n11. Include an example of a complete job configuration with snapshot actions:\n    ```json\n    {\n      \"url\": \"https://example.com\",\n      \"actions\": [\n        {\"type\": \"NAVIGATE\"},\n        {\"type\": \"WAIT\", \"wait\": {\"duration\": 2000}},\n        {\n          \"type\": \"SNAPSHOT\",\n          \"snapshot\": {\n            \"cookies\": true,\n            \"localStorage\": true\n          }\n        }\n      ]\n    }\n    ```\n12. Add information about retrieving snapshot artifacts, including the artifact type (SNAPSHOT) and expected JSON structure\n13. Review formatting, ensure consistent markdown styling with the rest of the README\n14. Add any relevant cross-references to API documentation or related features",
        "testStrategy": "1. Review the updated README.md to verify all sections are present:\n   - SNAPSHOT is listed in the available actions section\n   - Basic usage example is included and syntactically correct\n   - Advanced usage example with all configuration options is included\n   - Each configuration option is documented with clear explanations\n2. Validate all JSON examples are properly formatted and valid JSON:\n   - Copy each example and validate using a JSON validator\n   - Ensure proper escaping and quotation marks\n3. Verify markdown rendering:\n   - Preview the README.md in a markdown viewer or on GitHub\n   - Check that code blocks render correctly with syntax highlighting\n   - Verify headings, lists, and formatting are consistent\n4. Cross-reference with implementation:\n   - Compare documented configuration options with SnapshotConfigDto fields (Task 3)\n   - Verify action type name matches ActionType enum (Task 2)\n   - Ensure artifact type mentioned matches ArtifactType enum (Task 1)\n5. Test example configurations:\n   - Use the documented examples in actual API requests to verify they work\n   - Confirm the examples produce expected results\n6. Review for completeness:\n   - Verify all optional fields are documented\n   - Check that default behavior is clearly explained\n   - Ensure artifact retrieval information is accurate\n7. Peer review the documentation for clarity, accuracy, and completeness",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Update API documentation in docs/tech/05-api-reference.md to include snapshot action documentation section",
        "description": "Add comprehensive API reference documentation for the SNAPSHOT action type, including configuration schema, request/response examples, and detailed descriptions of all snapshot configuration options (cookies, localStorage, sessionStorage).",
        "details": "1. Open the file docs/tech/05-api-reference.md\n2. Locate the section documenting action types or create a new 'Action Types' section if it doesn't exist\n3. Add a new subsection titled 'SNAPSHOT Action' with the following structure:\n   - Overview: Brief description of what the SNAPSHOT action does (captures browser state including HTML, metadata, and optional storage data)\n   - Action Type Value: Document that the type field should be set to 'SNAPSHOT'\n4. Document the configuration schema for SnapshotConfigDto:\n   - Create a 'Configuration Options' subsection\n   - Document the 'cookies' field: type (boolean), optional, default behavior, description of what data is captured when enabled\n   - Document the 'localStorage' field: type (boolean), optional, default behavior, description of what data is captured when enabled\n   - Document the 'sessionStorage' field: type (boolean), optional, default behavior, description of what data is captured when enabled\n5. Add a 'Request Example' subsection showing a complete job configuration JSON with a SNAPSHOT action:\n   - Include basic example with no optional fields\n   - Include advanced example with all optional fields enabled\n   - Show proper JSON structure and formatting\n6. Add a 'Response/Artifact Structure' subsection:\n   - Document the artifact type (SNAPSHOT)\n   - Describe the JSON structure of the saved snapshot artifact\n   - Include example of captured data structure with fields: html, url, title, timestamp, cookies (if enabled), localStorage (if enabled), sessionStorage (if enabled)\n7. Add a 'Use Cases' subsection with practical examples:\n   - Capturing page state for debugging\n   - Preserving authentication state with cookies\n   - Archiving application state with storage data\n8. Add any relevant notes about browser compatibility, security considerations, or performance implications\n9. Ensure consistent formatting with existing documentation sections (headings, code blocks, tables)\n10. Add cross-references to related documentation sections if applicable",
        "testStrategy": "1. Review the updated documentation for completeness:\n   - Verify SNAPSHOT action is documented with clear overview\n   - Confirm all three configuration options (cookies, localStorage, sessionStorage) are documented with types and descriptions\n   - Check that both basic and advanced request examples are present and syntactically valid JSON\n   - Verify artifact structure documentation matches actual implementation\n2. Validate JSON examples by copying them and verifying they parse correctly\n3. Cross-reference documentation against actual implementation:\n   - Compare documented configuration fields with SnapshotConfigDto class definition\n   - Verify documented artifact structure matches what SnapshotActionHandler produces\n   - Confirm action type value matches ActionType enum\n4. Review documentation for clarity and completeness:\n   - Ensure technical terms are explained or linked to definitions\n   - Verify examples are realistic and helpful\n   - Check that formatting is consistent with other sections\n5. Have a team member review the documentation for accuracy and usability\n6. Test that documentation renders correctly if using a documentation generator or markdown viewer",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Update technical documentation in docs/tech/07-browser-pool-actions.md to add snapshot handler documentation following existing patterns",
        "description": "Add comprehensive technical documentation for the SnapshotActionHandler to the browser pool actions technical documentation file, following the established documentation patterns and structure used for other action handlers.",
        "details": "1. Open the file docs/tech/07-browser-pool-actions.md\n2. Review the existing documentation structure and patterns used for other action handlers to maintain consistency\n3. Add a new section titled 'SnapshotActionHandler' positioned appropriately among other handler documentation\n4. Document the handler's purpose: Captures the current state of a web page including HTML content, metadata (URL, title, timestamp), and optionally cookies, localStorage, and sessionStorage\n5. Document the class structure:\n   - Class name: SnapshotActionHandler\n   - Location: src/modules/jobs/handlers/snapshot-action.handler.ts\n   - Dependencies: JobArtifactService, Logger\n   - Implements: ActionHandler interface\n6. Document the execute method signature and parameters:\n   - Method: async execute(page: Page, config: ActionConfigDto, jobId: number): Promise<void>\n   - page: Puppeteer Page instance representing the browser page\n   - config: ActionConfigDto containing snapshot configuration options\n   - jobId: Identifier for the job to associate artifacts with\n7. Document configuration options from SnapshotConfigDto:\n   - cookies (boolean, optional): Whether to capture browser cookies\n   - localStorage (boolean, optional): Whether to capture localStorage data\n   - sessionStorage (boolean, optional): Whether to capture sessionStorage data\n8. Document the snapshot data structure that gets saved as an artifact:\n   - html: string (page HTML content)\n   - url: string (current page URL)\n   - title: string (page title)\n   - timestamp: string (ISO format capture time)\n   - cookies: array (if enabled)\n   - localStorage: object (if enabled)\n   - sessionStorage: object (if enabled)\n9. Document the artifact creation:\n   - ArtifactType: SNAPSHOT\n   - Content-Type: application/json\n   - Data format: JSON stringified snapshot object\n10. Add code examples showing typical usage patterns:\n    - Basic snapshot without optional features\n    - Snapshot with all optional features enabled\n11. Document error handling and edge cases:\n    - Handling pages without localStorage/sessionStorage support\n    - Cookie capture failures\n    - Large data handling considerations\n12. Add notes about integration with ActionHandlerFactory and registration in JobsModule\n13. Include cross-references to related documentation sections (ActionType enum, ArtifactType enum, API reference)\n14. Ensure all code examples use proper syntax highlighting and formatting consistent with the rest of the document",
        "testStrategy": "1. Review the updated documentation for completeness:\n   - Verify SnapshotActionHandler section is present and properly formatted\n   - Confirm class structure documentation includes all key components\n   - Check that execute method signature is accurately documented\n   - Verify all three configuration options are documented with types and descriptions\n2. Validate documentation accuracy:\n   - Cross-reference documented class structure with actual implementation in src/modules/jobs/handlers/snapshot-action.handler.ts\n   - Verify configuration options match SnapshotConfigDto definition\n   - Confirm snapshot data structure matches actual artifact content\n   - Check that artifact type and content-type are correctly documented\n3. Check consistency with existing patterns:\n   - Compare formatting and structure with other action handler documentation in the same file\n   - Verify section headings follow the same hierarchy and naming conventions\n   - Confirm code examples use the same syntax highlighting and formatting style\n   - Check that cross-references use the same linking format as other sections\n4. Validate code examples:\n   - Ensure all code examples are syntactically correct\n   - Verify examples demonstrate both basic and advanced usage\n   - Check that configuration objects in examples match the documented schema\n5. Test documentation usability:\n   - Have a developer unfamiliar with the implementation read the documentation and verify they understand how to use the handler\n   - Confirm all technical terms are either defined or linked to definitions\n   - Verify the documentation provides enough detail for maintenance and troubleshooting",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Fix JobsService test suite - add missing ArtifactStorageService mock provider",
        "description": "Add the missing ArtifactStorageService mock provider to the TestingModule setup in src/modules/jobs/jobs.service.spec.ts to resolve dependency injection errors causing all 10 tests to fail.",
        "details": "1. Open the test file src/modules/jobs/jobs.service.spec.ts\n2. Locate the TestingModule.createTestingModule() setup in the beforeEach hook\n3. Review the existing mock providers pattern used for BrowsersService and JobEventsGateway to understand the mocking approach\n4. Add a mock provider for ArtifactStorageService following the same pattern:\n   - Create a mockArtifactStorageService object with jest.fn() mocked methods for all public methods used by JobsService\n   - Common methods to mock might include: save, get, delete, list, or similar storage operations\n5. Add the provider to the providers array in the format:\n   {\n     provide: ArtifactStorageService,\n     useValue: mockArtifactStorageService\n   }\n6. Ensure the mock is properly reset in beforeEach if needed (mockArtifactStorageService.methodName.mockClear())\n7. Import ArtifactStorageService at the top of the file if not already imported\n8. Verify that all method calls to ArtifactStorageService in the tests have corresponding mock implementations\n9. Review each of the 10 failing tests to ensure they don't require specific mock return values or behaviors from ArtifactStorageService\n10. Add any necessary mock return values using mockResolvedValue() or mockReturnValue() for methods that need specific responses",
        "testStrategy": "1. Run the test suite: npm test jobs.service.spec.ts\n2. Verify all 10 tests now pass without dependency injection errors\n3. Check the test output for any remaining errors related to ArtifactStorageService\n4. Verify that the mock provider is properly instantiated by adding a test that checks mock method calls if needed\n5. Run the entire test suite to ensure no regressions: npm test\n6. Confirm test coverage remains stable or improves for the JobsService\n7. Verify that mock methods are being called as expected in tests that interact with artifact storage functionality\n8. Check that the mock follows the same pattern and style as other service mocks in the file for consistency",
        "status": "done",
        "dependencies": [
          4,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Fix NativeRecaptchaSolver test failures - implement missing sleep method",
        "description": "Add a private sleep method to the NativeRecaptchaSolver class to resolve test failures caused by calls to this.sleep() at multiple locations (lines 555, 691, 794, 1041, 1086, 1102, 1116) where the method doesn't exist, and update tests to properly mock or handle the sleep functionality.",
        "details": "1. Locate the NativeRecaptchaSolver class file (likely in src/modules/captcha/ or similar directory)\n2. Review all seven locations where this.sleep() is called (lines 555, 691, 794, 1041, 1086, 1102, 1116) to understand the expected behavior and parameters\n3. Add a private sleep method to the class with the following implementation:\n   private sleep(milliseconds: number): Promise<void> {\n     return new Promise(resolve => setTimeout(resolve, milliseconds));\n   }\n4. Alternatively, consider creating a shared utility function if sleep is needed across multiple classes:\n   - Create src/common/utils/sleep.util.ts with export function sleep(ms: number): Promise<void>\n   - Import and use the utility function instead of a class method\n5. Verify that all seven call sites use consistent parameter types (milliseconds as number)\n6. Update the corresponding test file (likely native-recaptcha-solver.spec.ts):\n   - Mock the sleep method using jest.spyOn() or jest.fn()\n   - Use jest.useFakeTimers() and jest.advanceTimersByTime() to control time in tests\n   - Ensure tests don't actually wait for real delays, making them fast and deterministic\n7. Add test cases specifically for the sleep method behavior if implementing as a utility\n8. Review test failures to ensure all four failing tests are addressed by the implementation",
        "testStrategy": "1. Run the NativeRecaptchaSolver test suite and verify all four previously failing tests now pass\n2. Verify the sleep method is properly defined and returns a Promise<void>\n3. Test that sleep method resolves after the specified delay using jest.useFakeTimers():\n   - Call sleep(1000) and advance timers by 1000ms\n   - Verify the promise resolves correctly\n4. Verify all seven call sites (lines 555, 691, 794, 1041, 1086, 1102, 1116) execute without errors\n5. Run tests with jest.useFakeTimers() to ensure tests complete quickly without actual delays\n6. Verify mock implementations in tests properly stub the sleep method\n7. Check test coverage to ensure the sleep method and all call sites are covered\n8. Run the full test suite to ensure no regressions in other tests",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Fix JobEventsGateway test failure - handle undefined client in handlePong test",
        "description": "Resolve the TypeError in job-events.gateway.spec.ts at line 219 where the test attempts to access gateway['clients'].get('socket-id-123').lastPong without ensuring the client exists. Update the test setup to properly initialize the client before accessing its properties or add appropriate null/undefined checks.",
        "details": "1. Open the test file src/modules/jobs/gateways/job-events.gateway.spec.ts\n2. Locate the test case at line 219 that tests the handlePong functionality\n3. Review the test setup (beforeEach or within the specific test) to understand how the clients Map is initialized\n4. Identify the issue: The test calls gateway['clients'].get('socket-id-123').lastPong but the client with ID 'socket-id-123' may not be properly added to the clients Map\n5. Implement one of the following solutions:\n   Option A - Initialize client in test setup:\n   - Before accessing the client, add it to the clients Map: gateway['clients'].set('socket-id-123', { id: 'socket-id-123', lastPong: Date.now(), socket: mockSocket })\n   - Ensure the mock client object has all required properties (id, lastPong, socket)\n   Option B - Add null checks in the test:\n   - Modify the test to check if the client exists before accessing properties: const client = gateway['clients'].get('socket-id-123'); expect(client).toBeDefined(); expect(client.lastPong).toBeDefined();\n6. Review other tests in the same file to ensure consistent client initialization patterns\n7. Consider if the handlePong method itself needs null checks (review the implementation in job-events.gateway.ts)\n8. If the gateway implementation lacks null checks, add defensive programming: const client = this.clients.get(socketId); if (!client) return; client.lastPong = Date.now();\n9. Verify the mock socket object used in tests has all necessary properties that handlePong might access",
        "testStrategy": "1. Run the specific failing test: npm test -- job-events.gateway.spec.ts -t 'handlePong'\n2. Verify the test at line 219 now passes without TypeError\n3. Run the entire JobEventsGateway test suite to ensure no regressions: npm test job-events.gateway.spec.ts\n4. Verify all tests pass and no new failures are introduced\n5. Test the actual handlePong implementation with various scenarios:\n   - Test with a valid client ID that exists in the clients Map\n   - Test with an invalid/non-existent client ID to ensure graceful handling\n   - Test that lastPong timestamp is properly updated when client exists\n6. Add additional test cases if needed:\n   - Test handlePong with undefined client ID\n   - Test handlePong with null client ID\n   - Test handlePong updates lastPong to current timestamp\n7. Review code coverage to ensure the handlePong method and its edge cases are adequately tested\n8. Perform manual testing if applicable by connecting a WebSocket client and verifying pong handling works correctly",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Handle Playwright browser installation requirement in StealthService tests",
        "description": "Add proper test setup to check for Playwright browser availability in stealth.service.spec.ts and skip tests gracefully when browsers are not installed, preventing test failures due to missing browser binaries. Include documentation for running browser installation commands.",
        "details": "1. Open the test file src/modules/stealth/stealth.service.spec.ts\n2. Add a beforeAll hook at the top of the test suite to check for Playwright browser availability:\n   - Import playwright from '@playwright/test' or 'playwright'\n   - Create an async function to check if browsers are installed by attempting to launch a browser with a timeout\n   - Use a try-catch block to detect if browsers are missing (typically throws an error about executable not found)\n3. Implement graceful test skipping:\n   - Set a suite-level variable (e.g., browsersAvailable: boolean) based on the check result\n   - Use beforeEach or individual test conditionals to skip tests when browsersAvailable is false\n   - Alternatively, use jest.describe.skip() to skip the entire suite if browsers are not available\n4. Add informative console warnings when tests are skipped:\n   - Log a clear message: 'Skipping StealthService tests: Playwright browsers not installed. Run: npx playwright install'\n5. Create or update test documentation:\n   - Add a comment block at the top of the test file explaining the browser requirement\n   - Update the project's test README or contributing guide with instructions to run 'npx playwright install' before running tests\n6. Consider adding a package.json script for test setup:\n   - Add a 'test:setup' script that runs 'npx playwright install'\n   - Update CI/CD configuration to run browser installation before tests\n7. Handle the three specific failing tests by ensuring they check browser availability before execution\n8. Add error handling for browser launch failures that provides actionable error messages",
        "testStrategy": "1. Run the StealthService test suite without Playwright browsers installed and verify:\n   - Tests are skipped gracefully with informative messages\n   - No test failures occur due to missing browsers\n   - The skip message includes the installation command\n2. Run 'npx playwright install' and verify:\n   - All three previously failing tests now execute successfully\n   - Browser availability check passes in beforeAll hook\n   - Tests run without any browser-related errors\n3. Test the beforeAll hook logic:\n   - Mock browser availability check to return false and verify tests are skipped\n   - Mock browser availability check to return true and verify tests execute\n4. Verify documentation updates:\n   - Check that test file comments clearly explain browser requirements\n   - Confirm README or contributing guide includes browser installation instructions\n5. Run the entire test suite to ensure no regressions in other tests\n6. Test in CI/CD environment to ensure browser installation step is properly configured",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Add configuration support for executeScript action feature flag",
        "description": "Create environment variable validation and configuration service support for the ENABLE_EXECUTE_SCRIPT feature flag to control whether executeScript actions are permitted. This security-critical flag defaults to false and must be checked before allowing script execution.",
        "details": "1. Open or create the environment validation schema file (typically src/config/env.validation.ts or src/config/configuration.ts)\n2. Add ENABLE_EXECUTE_SCRIPT to the validation schema:\n   - Type: boolean\n   - Default value: false\n   - Add validation using class-validator decorators (@IsBoolean(), @IsOptional())\n   - Example: ENABLE_EXECUTE_SCRIPT: process.env.ENABLE_EXECUTE_SCRIPT === 'true'\n3. Update the ConfigService or create a configuration module:\n   - Add a getter method: getExecuteScriptEnabled(): boolean\n   - Return the ENABLE_EXECUTE_SCRIPT value from environment configuration\n   - Example implementation: return this.configService.get<boolean>('ENABLE_EXECUTE_SCRIPT', false);\n4. Update .env.example file:\n   - Add ENABLE_EXECUTE_SCRIPT=false with clear documentation\n   - Include security warning comment explaining the risks of enabling this feature\n   - Document that this controls whether executeScript actions are permitted\n5. Create or update an ExecuteScriptActionHandler guard/validator:\n   - Inject ConfigService into the handler constructor\n   - In the execute method, check the flag before processing: if (!this.configService.getExecuteScriptEnabled()) throw new ForbiddenException('executeScript action is disabled')\n   - Add appropriate error handling and logging\n6. Consider adding the flag check to ActionHandlerFactory if executeScript handler registration should be conditional\n7. Update any existing executeScript action handler to include this validation at the beginning of the execute method",
        "testStrategy": "1. Unit tests for environment validation:\n   - Test that ENABLE_EXECUTE_SCRIPT defaults to false when not set\n   - Test that ENABLE_EXECUTE_SCRIPT=true is parsed correctly\n   - Test that invalid values are rejected or coerced appropriately\n2. Unit tests for ConfigService getter:\n   - Mock ConfigService and verify getExecuteScriptEnabled() returns correct boolean values\n   - Test default false behavior when environment variable is not set\n3. Integration tests for executeScript action blocking:\n   - Create a test job with executeScript action when flag is false\n   - Verify execution throws ForbiddenException with appropriate message\n   - Set ENABLE_EXECUTE_SCRIPT=true and verify the same action executes successfully\n4. Verify .env.example documentation:\n   - Confirm ENABLE_EXECUTE_SCRIPT entry exists with security warning\n   - Verify default value is documented as false\n5. Security validation tests:\n   - Attempt to bypass the flag check and verify it cannot be circumvented\n   - Test that the flag is checked on every executeScript action execution\n6. End-to-end test with actual job execution to confirm the feature flag properly gates script execution functionality",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create executeScript action handler and tests",
        "description": "Implement the ExecuteScriptActionHandler class following the existing handler pattern to execute JavaScript/TypeScript code in the browser context using Playwright's page.evaluate(), with support for both synchronous and asynchronous execution, structured result formatting, and comprehensive unit tests covering success scenarios, error handling, async execution, and security validations.",
        "details": "1. Create a new file src/modules/jobs/handlers/execute-script-action.handler.ts\n2. Import necessary dependencies: Injectable decorator from @nestjs/common, ActionType from action-config.dto, ConfigService for feature flag checking, Logger for logging\n3. Import Puppeteer/Playwright types (Page) and any required services\n4. Define the ExecuteScriptActionHandler class with @Injectable() decorator\n5. Implement constructor to inject required services (ConfigService, Logger):\n   constructor(\n     private readonly configService: ConfigService,\n     private readonly logger: Logger\n   ) {}\n6. Implement the execute method with signature: async execute(page: Page, config: ExecuteScriptConfigDto): Promise<ExecuteScriptResult>\n7. Add feature flag check at the start of execute method:\n   - Call this.configService.getExecuteScriptEnabled() or equivalent\n   - If disabled, throw an error or return a failure result indicating the feature is disabled\n8. Implement script execution logic:\n   - Use page.evaluate() to execute the script in browser context\n   - Wrap execution in try-catch to handle script errors\n   - Support both sync and async scripts by awaiting the evaluate result\n   - Handle script return values and serialize them appropriately\n9. Structure the return value as ExecuteScriptResult with fields:\n   - success: boolean\n   - result: any (the script return value)\n   - error?: string (error message if execution failed)\n   - executionTime?: number (optional performance metric)\n10. Add comprehensive error handling for:\n    - Script syntax errors\n    - Runtime exceptions\n    - Timeout scenarios\n    - Serialization issues with complex return values\n11. Add logging for script execution start, success, and failures\n12. Create test file src/modules/jobs/handlers/execute-script-action.handler.spec.ts\n13. Set up test suite with beforeEach hook to create testing module with mocked dependencies:\n    - Mock ConfigService with getExecuteScriptEnabled method\n    - Mock Logger\n    - Mock Playwright Page object with evaluate method\n14. Write unit tests covering:\n    - Successful synchronous script execution returning primitive values\n    - Successful script execution returning objects/arrays\n    - Async script execution with Promise resolution\n    - Script throwing errors/exceptions\n    - Feature flag disabled scenario (should throw or return error)\n    - Page.evaluate throwing errors\n    - Script timeout scenarios\n    - Null/undefined return values\n    - Complex object serialization\n15. Use jest.spyOn to verify page.evaluate is called with correct parameters\n16. Verify error messages are properly captured and returned in result structure\n17. Test that logger methods are called appropriately for different scenarios",
        "testStrategy": "1. Run the test suite with jest and verify all tests pass: npm test execute-script-action.handler.spec.ts\n2. Generate code coverage report: npm test -- --coverage execute-script-action.handler.spec.ts\n3. Verify code coverage exceeds 80% threshold for statement, branch, and function coverage\n4. Test successful script execution:\n   - Mock page.evaluate to return a value\n   - Verify execute method returns success: true with correct result\n5. Test script with errors:\n   - Mock page.evaluate to throw an error\n   - Verify execute method returns success: false with error message\n6. Test async script execution:\n   - Mock page.evaluate to return a Promise\n   - Verify the handler properly awaits and returns the resolved value\n7. Test feature flag disabled:\n   - Mock configService.getExecuteScriptEnabled() to return false\n   - Verify execute method throws error or returns failure result\n8. Test with various return types (string, number, boolean, object, array, null, undefined)\n9. Verify logger is called with appropriate messages for each scenario\n10. Run integration with other handlers to ensure consistent pattern adherence\n11. Verify TypeScript compilation succeeds with no type errors",
        "status": "done",
        "dependencies": [
          16
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Update DTOs and validation for executeScript action",
        "description": "Extend the ActionConfigDto to support the new executeScript action type by adding ExecuteScriptConfig interface with script, args, and returnResult properties, implementing class-validator decorators for validation, and ensuring feature flag validation to prevent unauthorized script execution.",
        "details": "1. Open the file src/modules/jobs/dto/action-config.dto.ts\n2. Import necessary validation decorators from class-validator: @IsString, @IsOptional, @IsBoolean, @IsArray, @ValidateNested, @IsNotEmpty\n3. Import ConfigService from @nestjs/config to access feature flag\n4. Create a new ExecuteScriptConfigDto class before ActionConfigDto:\n   - Add @IsString() @IsNotEmpty() script: string field for the JavaScript code to execute\n   - Add @IsOptional() @IsArray() args?: any[] field for optional arguments to pass to the script\n   - Add @IsOptional() @IsBoolean() returnResult?: boolean field with default true to control result capture\n5. Update the ActionType enum to include 'EXECUTE_SCRIPT' if not already present\n6. In the ActionConfigDto class, add a conditional validation for executeScript:\n   - Add @ValidateNested() @Type(() => ExecuteScriptConfigDto) @IsOptional() executeScript?: ExecuteScriptConfigDto field\n7. Create a custom validator decorator @IsExecuteScriptEnabled() that:\n   - Checks ConfigService.get('ENABLE_EXECUTE_SCRIPT') feature flag\n   - Throws ValidationException with message 'executeScript action is disabled. Set ENABLE_EXECUTE_SCRIPT=true to enable.' if flag is false\n   - Apply this decorator to the executeScript field in ActionConfigDto\n8. Update any ActionType union types or type guards to include 'EXECUTE_SCRIPT'\n9. Ensure the executeScript configuration is properly typed in the ActionConfigDto discriminated union based on action type\n10. Add JSDoc comments documenting the security implications and feature flag requirement",
        "testStrategy": "1. Create unit tests for ExecuteScriptConfigDto validation:\n   - Test that script field is required and rejects empty strings\n   - Test that args field accepts arrays and is optional\n   - Test that returnResult field accepts boolean values and defaults appropriately\n   - Test that invalid types are rejected with proper validation errors\n2. Create unit tests for ActionConfigDto with executeScript:\n   - Test that executeScript config validates correctly when action type is EXECUTE_SCRIPT\n   - Test that validation passes when ENABLE_EXECUTE_SCRIPT flag is true\n   - Test that validation fails with appropriate error when ENABLE_EXECUTE_SCRIPT flag is false\n   - Test that executeScript field is optional for other action types\n3. Integration tests:\n   - Mock ConfigService and test feature flag validation behavior\n   - Test complete job creation DTO with executeScript action\n   - Verify error messages are clear and actionable\n4. Compile TypeScript to ensure no type errors\n5. Run full test suite to ensure backward compatibility with existing action types",
        "status": "done",
        "dependencies": [
          2,
          16
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Integrate executeScript handler into job processing pipeline",
        "description": "Wire up the ExecuteScriptActionHandler into the existing job processing system by registering it as a provider in JobsModule, updating the ActionHandlerFactory to route executeScript actions to the handler, and ensuring proper error handling and result storage during job execution.",
        "details": "1. Open the file src/modules/jobs/jobs.module.ts\n2. Import the ExecuteScriptActionHandler class from './handlers/execute-script-action.handler'\n3. Add ExecuteScriptActionHandler to the providers array in the @Module decorator, maintaining consistency with other action handlers like SnapshotActionHandler\n4. Verify that all services required by ExecuteScriptActionHandler (ConfigService, Logger, etc.) are already registered as providers\n5. Open the file src/modules/jobs/factories/action-handler.factory.ts\n6. Import the ExecuteScriptActionHandler class from '../handlers/execute-script-action.handler'\n7. Import ActionType enum from '../dto/action-config.dto' if not already imported\n8. Inject ExecuteScriptActionHandler as a dependency in the ActionHandlerFactory constructor (e.g., private readonly executeScriptActionHandler: ExecuteScriptActionHandler)\n9. Within the constructor body, register the handler by mapping ActionType.EXECUTE_SCRIPT to the executeScriptActionHandler instance in the handlers map/registry\n10. Follow the same pattern used for SnapshotActionHandler registration (reference Task 5)\n11. Ensure the action routing logic in the factory's getHandler method properly returns the ExecuteScriptActionHandler when ActionType.EXECUTE_SCRIPT is requested\n12. Add error handling in the handler execution flow to catch and log script execution errors with appropriate context\n13. Verify that script execution results are stored correctly - either in the job result field or as an artifact depending on the returnResult configuration\n14. Add logging statements at key points: handler registration, action dispatch, script execution start/completion, and error scenarios\n15. Review the job execution pipeline to ensure executeScript actions flow through the same validation and execution stages as other action types",
        "testStrategy": "1. Create unit tests in action-handler.factory.spec.ts:\n   a. Mock ExecuteScriptActionHandler and verify it's injected into the factory constructor\n   b. Test that getHandler(ActionType.EXECUTE_SCRIPT) returns the ExecuteScriptActionHandler instance\n   c. Verify the handler is properly registered in the factory's handler map\n2. Create integration tests in jobs.module.spec.ts:\n   a. Bootstrap the JobsModule and verify ExecuteScriptActionHandler can be resolved from the DI container\n   b. Test that ActionHandlerFactory can successfully inject and use ExecuteScriptActionHandler\n3. Create end-to-end tests for executeScript action execution:\n   a. Create a job with an executeScript action and verify it executes successfully\n   b. Test that script results are stored correctly in job results or artifacts\n   c. Verify error handling when script execution fails\n   d. Test that feature flag validation prevents execution when ENABLE_EXECUTE_SCRIPT is false\n4. Verify logging output contains appropriate messages for handler registration and script execution events\n5. Run the full test suite to ensure no regressions in existing action handler functionality\n6. Test the complete job processing pipeline with executeScript actions mixed with other action types",
        "status": "done",
        "dependencies": [
          17,
          18,
          5,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create E2E tests for executeScript action",
        "description": "Develop comprehensive end-to-end integration tests for the executeScript action functionality in test/execute-script-action.e2e-spec.ts, covering complete job workflows with various script execution scenarios including simple scripts, DOM access, arguments, async execution, error handling, feature flag validation, and multiple actions per job.",
        "details": "1. Create the test file test/execute-script-action.e2e-spec.ts in the test directory\n2. Import necessary testing utilities: Test, TestingModule from @nestjs/testing, INestApplication from @nestjs/common\n3. Import required modules and services: AppModule, JobsService, JobArtifactService, ActionType, ArtifactType, ConfigService\n4. Import supertest for HTTP request testing and any required types for validation\n5. Set up test suite with beforeAll hook to:\n   - Create a testing module using Test.createTestingModule with AppModule\n   - Compile the module and create the NestJS application instance\n   - Initialize the application with app.init()\n   - Override ConfigService to enable ENABLE_EXECUTE_SCRIPT feature flag for tests\n6. Set up afterAll hook to close the application and clean up resources\n7. Implement test case: 'should execute simple script and return value'\n   - Create job with executeScript action containing script: 'return 2 + 2;'\n   - Submit job via POST /jobs endpoint\n   - Poll job status until completion\n   - Verify job completes successfully with status 'completed'\n   - Verify result contains expected value (4)\n8. Implement test case: 'should execute script accessing DOM elements'\n   - Create job with navigate action to a test page, then executeScript action with script: 'return document.title;'\n   - Verify script can access and return DOM properties\n   - Verify result contains the page title\n9. Implement test case: 'should execute script with arguments passed'\n   - Create job with executeScript action containing script: 'return arguments[0] + arguments[1];' and args: [5, 10]\n   - Verify script receives and processes arguments correctly\n   - Verify result contains expected sum (15)\n10. Implement test case: 'should execute async script'\n    - Create job with executeScript action containing async script: 'return await Promise.resolve(\"async result\");'\n    - Verify async script execution completes successfully\n    - Verify result contains expected async value\n11. Implement test case: 'should handle script execution errors'\n    - Create job with executeScript action containing script that throws error: 'throw new Error(\"Test error\");'\n    - Verify job fails with appropriate error status\n    - Verify error message is captured and returned in job response\n12. Implement test case: 'should reject job when feature flag is disabled'\n    - Override ConfigService to set ENABLE_EXECUTE_SCRIPT to false\n    - Create job with executeScript action\n    - Verify job is rejected with appropriate error message about feature being disabled\n    - Restore feature flag to enabled state after test\n13. Implement test case: 'should handle multiple executeScript actions in single job'\n    - Create job with multiple executeScript actions with different scripts\n    - Verify all scripts execute in sequence\n    - Verify each script's result is properly stored and accessible\n    - Verify results are returned in correct order in job response\n14. Follow existing E2E test patterns from snapshot-action.e2e-spec.ts:\n    - Use consistent job creation and submission patterns\n    - Implement proper polling mechanism for job completion\n    - Use appropriate assertions and error messages\n    - Clean up test data after each test if necessary\n15. Add helper functions as needed:\n    - createJobWithExecuteScript(script, args?, returnResult?)\n    - pollJobUntilComplete(jobId, maxAttempts, interval)\n    - verifyExecuteScriptResult(result, expectedValue)\n16. Ensure tests are isolated and can run independently\n17. Add descriptive test names and comments explaining complex scenarios",
        "testStrategy": "1. Run the e2e test suite with npm run test:e2e execute-script-action.e2e-spec.ts and verify all tests pass\n2. Verify test coverage for integration scenarios:\n   - Simple script execution returning primitive values\n   - Script accessing DOM elements and browser APIs\n   - Script with multiple arguments of different types\n   - Async script execution with promises\n   - Script execution errors and error handling\n   - Feature flag disabled scenario\n   - Multiple executeScript actions in sequence\n3. Test with different script complexities:\n   - Single line scripts\n   - Multi-line scripts with complex logic\n   - Scripts with closures and scope access\n4. Verify proper artifact creation and storage:\n   - Check that results are stored as artifacts with correct type\n   - Verify artifact data structure matches expected format\n   - Confirm artifacts are retrievable via job response\n5. Test error scenarios:\n   - Syntax errors in script code\n   - Runtime errors during execution\n   - Timeout scenarios for long-running scripts\n6. Verify feature flag integration:\n   - Test behavior when flag is enabled vs disabled\n   - Confirm appropriate error messages when disabled\n7. Performance testing:\n   - Verify tests complete within reasonable time\n   - Check for memory leaks or resource cleanup issues\n8. Run tests multiple times to ensure consistency and no flaky behavior\n9. Verify test cleanup:\n   - Confirm no test data persists between test runs\n   - Verify application state is properly reset\n10. Compare test patterns with snapshot-action.e2e-spec.ts to ensure consistency in testing approach and code style",
        "status": "done",
        "dependencies": [
          8,
          17,
          19
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Update documentation for executeScript action",
        "description": "Update project documentation to include the new executeScript action in README.md, Postman collection, and API reference documentation, with comprehensive examples, security warnings, and configuration details for the ENABLE_EXECUTE_SCRIPT environment variable.",
        "details": "1. Update README.md:\n   a. Locate the 'Available Actions' section and add executeScript to the list with description: 'EXECUTE_SCRIPT - Executes custom JavaScript code in the browser context with optional arguments and return value capture'\n   b. Create or locate 'Action Configuration Examples' section\n   c. Add executeScript subsection with the following examples:\n      - Basic script execution: Simple script that returns a value\n      - Script with return value: Demonstrate returnResult configuration\n      - Script with arguments: Show how to pass args array to script\n      - Async script example: Demonstrate async/await or Promise-based scripts\n      - DOM manipulation example: Show script accessing and modifying DOM elements\n   d. Locate the 'Configuration' or 'Environment Variables' section\n   e. Add ENABLE_EXECUTE_SCRIPT documentation:\n      - Type: boolean\n      - Default: false\n      - Description: Controls whether executeScript actions are permitted\n      - Example: ENABLE_EXECUTE_SCRIPT=true\n   f. Add security warnings section:\n      - Warn about code injection risks\n      - Emphasize that this feature should only be enabled in trusted environments\n      - Recommend keeping it disabled in production unless absolutely necessary\n      - Note that scripts execute with full browser context access\n2. Update Postman collection (Browsers-API.postman_collection.json):\n   a. Add new request examples for executeScript action\n   b. Include examples matching README patterns: basic, with args, async, DOM manipulation\n   c. Add environment variable for ENABLE_EXECUTE_SCRIPT in collection variables\n   d. Include pre-request scripts or tests demonstrating validation\n3. Update API reference documentation (docs/tech/05-api-reference.md):\n   a. Add 'EXECUTE_SCRIPT Action' subsection following the pattern from Task 10\n   b. Document the action type value: 'EXECUTE_SCRIPT'\n   c. Document configuration schema:\n      - script: string (required) - JavaScript code to execute\n      - args: any[] (optional) - Arguments passed to script\n      - returnResult: boolean (optional) - Whether to capture return value\n   d. Include request/response examples with different configurations\n   e. Document error responses when feature flag is disabled\n4. Create or update security documentation:\n   a. Create docs/tech/security.md or add section to existing security docs\n   b. Document executeScript security considerations:\n      - Code injection attack vectors\n      - Privilege escalation risks\n      - Best practices for script validation\n      - Recommendations for access control\n      - Audit logging considerations\n   c. Provide guidelines for safe usage patterns\n5. Update OpenAPI/Swagger specifications if they exist:\n   a. Add executeScript action type to ActionType enum\n   b. Define ExecuteScriptConfig schema\n   c. Add examples to API specification\n   d. Document security requirements and feature flag dependency",
        "testStrategy": "1. Review README.md updates:\n   - Verify executeScript is listed in Available Actions with clear description\n   - Confirm all 5 example types are present and syntactically correct\n   - Check ENABLE_EXECUTE_SCRIPT is documented in configuration section with type, default, and description\n   - Verify security warnings are prominent and comprehensive\n   - Test all code examples by copying them into actual API requests\n2. Validate Postman collection:\n   - Import updated collection into Postman\n   - Execute each executeScript example request\n   - Verify requests work with ENABLE_EXECUTE_SCRIPT=true\n   - Confirm requests fail appropriately with ENABLE_EXECUTE_SCRIPT=false\n   - Check that collection variables are properly defined\n3. Review API reference documentation:\n   - Verify executeScript action section follows established patterns from other actions\n   - Confirm all configuration properties are documented with types and descriptions\n   - Check that request/response examples are valid JSON and match actual API behavior\n   - Verify error response documentation is accurate\n4. Validate security documentation:\n   - Review security section for completeness and accuracy\n   - Verify all major risk categories are covered\n   - Check that best practices are actionable and specific\n   - Ensure recommendations align with industry standards\n5. Test OpenAPI/Swagger specs if updated:\n   - Validate spec file with OpenAPI validator tools\n   - Generate API client from spec and verify executeScript types are correct\n   - Check that examples render properly in Swagger UI\n6. Cross-reference documentation:\n   - Ensure consistency across README, API reference, and Postman collection\n   - Verify all examples use the same configuration property names\n   - Check that security warnings are consistent across all documentation",
        "status": "done",
        "dependencies": [
          2,
          16,
          18,
          19
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-17T21:44:40.857Z",
      "description": "Default tasks context",
      "updated": "2025-11-18T20:14:58.184Z"
    }
  }
}