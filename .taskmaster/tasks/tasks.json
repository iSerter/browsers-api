{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Update ArtifactType enum to include SNAPSHOT type",
        "description": "Add a new SNAPSHOT type to the ArtifactType enum in the job-artifact entity to support snapshot artifact functionality as the foundation for the snapshot feature.",
        "details": "1. Locate the file src/modules/jobs/entities/job-artifact.entity.ts\n2. Find the ArtifactType enum definition\n3. Add a new enum value 'SNAPSHOT' to the existing ArtifactType enum\n4. Ensure the enum value follows the naming convention of other artifact types (e.g., uppercase)\n5. Position the new SNAPSHOT type logically within the enum (typically at the end or grouped with related types)\n6. Verify that the enum is properly exported if it's used in other modules\n7. Check if there are any type guards or validation functions that reference ArtifactType and may need updating\n8. Review any existing switch statements or conditional logic that handle ArtifactType to ensure they won't break with the new type (add default cases if needed)\n9. Update any TypeScript type definitions or interfaces that may be affected by this change",
        "testStrategy": "1. Verify the SNAPSHOT enum value is added correctly by importing ArtifactType in a test file and checking it exists\n2. Compile the TypeScript code to ensure no type errors are introduced\n3. Run existing unit tests for the job-artifact entity to ensure backward compatibility\n4. Create a simple test that instantiates or references ArtifactType.SNAPSHOT to confirm it's accessible\n5. Check that the enum can be used in type annotations and assignments without errors\n6. Verify that any ORM queries or database operations that use ArtifactType still function correctly\n7. Review the compiled JavaScript output to ensure the enum value is properly transpiled",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Update ActionType enum to include SNAPSHOT action type",
        "description": "Add a new SNAPSHOT action type to the ActionType enum in the action-config DTO to enable snapshot operations within the job action configuration system.",
        "details": "1. Navigate to the file src/modules/jobs/dto/action-config.dto.ts\n2. Locate the ActionType enum definition within the file\n3. Add a new enum value 'SNAPSHOT' to the existing ActionType enum, following the established naming convention (uppercase)\n4. Position the SNAPSHOT type appropriately within the enum - consider grouping it with related action types or placing it at the end\n5. Ensure the enum maintains consistent formatting with existing values\n6. Verify that the ActionType enum is properly exported for use in other modules\n7. Check if the enum is used in any type guards, validators, or switch statements that may need updating\n8. Review any associated validation decorators or pipes that reference ActionType to ensure they will accept the new value\n9. Document the purpose of the SNAPSHOT action type with a comment if the enum includes documentation\n10. Ensure consistency with the ArtifactType.SNAPSHOT addition from Task 1",
        "testStrategy": "1. Verify the SNAPSHOT enum value exists by importing ActionType and checking that ActionType.SNAPSHOT is defined\n2. Compile the TypeScript code to confirm no type errors are introduced\n3. Run existing unit tests for DTOs and action configuration to ensure backward compatibility\n4. Create a test that instantiates an action config object with ActionType.SNAPSHOT to verify it's accepted by validation\n5. If class-validator decorators are present, test that SNAPSHOT passes validation rules\n6. Verify that any existing switch statements or type guards handle the new enum value appropriately (or add TODO comments where updates are needed)\n7. Check that the enum can be serialized and deserialized correctly in API requests",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Add snapshot configuration fields to ActionConfigDto with validation decorators",
        "description": "Extend the ActionConfigDto class to include configuration fields for snapshot operations (cookies, localStorage, sessionStorage) with proper validation decorators to ensure data integrity and type safety.",
        "details": "1. Open the file src/modules/jobs/dto/action-config.dto.ts\n2. Import necessary validation decorators from class-validator: @IsOptional, @IsBoolean, @ValidateNested, @IsObject, @IsArray, @IsString\n3. Import Type from class-transformer for nested object validation\n4. Add a new nested DTO class 'SnapshotConfigDto' before the ActionConfigDto class:\n   - Add @IsOptional() @IsBoolean() cookies?: boolean field to control cookie capture\n   - Add @IsOptional() @IsBoolean() localStorage?: boolean field to control localStorage capture\n   - Add @IsOptional() @IsBoolean() sessionStorage?: boolean field to control sessionStorage capture\n5. In the ActionConfigDto class, add a new property for snapshot configuration:\n   - Add @IsOptional() @ValidateNested() @Type(() => SnapshotConfigDto) snapshotConfig?: SnapshotConfigDto\n6. Ensure the snapshotConfig field is only relevant when actionType is SNAPSHOT by adding conditional validation logic or documentation\n7. Add JSDoc comments explaining the purpose of each field and the SnapshotConfigDto class\n8. Verify that all imports are properly organized at the top of the file\n9. Ensure consistent code formatting with the rest of the file (indentation, spacing)\n10. Consider adding default values documentation for when fields are omitted",
        "testStrategy": "1. Create unit tests for SnapshotConfigDto validation:\n   - Test that all fields accept boolean values when provided\n   - Test that all fields are optional and can be omitted\n   - Test that invalid types (strings, numbers) are rejected with appropriate validation errors\n2. Create unit tests for ActionConfigDto with snapshotConfig:\n   - Test that snapshotConfig accepts a valid SnapshotConfigDto object\n   - Test that snapshotConfig is optional and can be null/undefined\n   - Test that nested validation works correctly (invalid nested objects are rejected)\n3. Integration test: Create a complete ActionConfigDto with actionType SNAPSHOT and valid snapshotConfig, validate it passes\n4. Integration test: Create ActionConfigDto with invalid snapshotConfig values and verify validation fails with descriptive error messages\n5. Compile TypeScript to ensure no type errors\n6. Run all existing DTO tests to ensure backward compatibility\n7. Verify that the validation decorators work correctly by instantiating the DTO with various valid and invalid payloads",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create SnapshotActionHandler class with execute method for capturing browser state",
        "description": "Implement the SnapshotActionHandler class that captures HTML content, metadata, and conditionally captures cookies, localStorage, and sessionStorage based on configuration, then packages the data as JSON and saves it as an artifact.",
        "details": "1. Create a new file src/modules/jobs/handlers/snapshot-action.handler.ts\n2. Import necessary dependencies: Injectable decorator from @nestjs/common, ActionType from action-config.dto, ArtifactType from job-artifact.entity, SnapshotConfigDto from action-config.dto\n3. Import Puppeteer types (Page) and any required services (JobArtifactService, Logger)\n4. Define the SnapshotActionHandler class with @Injectable() decorator\n5. Implement constructor to inject required services (JobArtifactService, Logger)\n6. Create the execute method with signature: async execute(page: Page, config: SnapshotConfigDto, jobId: string): Promise<void>\n7. Inside execute method:\n   a. Capture HTML content using page.content() - this is always captured\n   b. Capture metadata including URL (page.url()), title (page.title()), timestamp (new Date().toISOString()), viewport dimensions\n   c. Conditionally capture cookies using page.cookies() if config.cookies is true\n   d. Conditionally capture localStorage by evaluating page.evaluate(() => JSON.stringify(localStorage)) if config.localStorage is true\n   e. Conditionally capture sessionStorage by evaluating page.evaluate(() => JSON.stringify(sessionStorage)) if config.sessionStorage is true\n8. Package all captured data into a structured JSON object with properties: html, metadata, cookies (optional), localStorage (optional), sessionStorage (optional)\n9. Convert the JSON object to a string using JSON.stringify()\n10. Call JobArtifactService to save the artifact with type ArtifactType.SNAPSHOT, including jobId, data, and appropriate metadata\n11. Add error handling with try-catch blocks and appropriate logging\n12. Add JSDoc comments documenting the class, method parameters, and return values",
        "testStrategy": "1. Create unit tests in snapshot-action.handler.spec.ts:\n   a. Mock Puppeteer Page object with methods: content(), url(), title(), cookies(), evaluate()\n   b. Mock JobArtifactService with save method\n   c. Test execute method captures HTML content correctly\n   d. Test execute method captures metadata (URL, title, timestamp)\n   e. Test conditional cookie capture when config.cookies is true/false\n   f. Test conditional localStorage capture when config.localStorage is true/false\n   g. Test conditional sessionStorage capture when config.sessionStorage is true/false\n   h. Test that all captured data is properly packaged into JSON structure\n   i. Test that JobArtifactService.save is called with correct parameters (jobId, ArtifactType.SNAPSHOT, JSON data)\n   j. Test error handling when page methods throw errors\n   k. Test that logger is called appropriately for errors and success\n2. Create integration tests:\n   a. Test with real Puppeteer page instance on a test HTML page\n   b. Verify captured HTML matches expected content\n   c. Verify captured cookies, localStorage, and sessionStorage match test data\n   d. Verify saved artifact can be retrieved and parsed correctly\n3. Test edge cases: empty localStorage/sessionStorage, pages with no cookies, pages with special characters in HTML",
        "status": "done",
        "dependencies": [
          1,
          3
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Register SnapshotActionHandler in ActionHandlerFactory constructor",
        "description": "Update the ActionHandlerFactory to instantiate and register the SnapshotActionHandler, mapping it to the SNAPSHOT action type so the factory can properly route snapshot actions to the appropriate handler.",
        "details": "1. Open the file src/modules/jobs/factories/action-handler.factory.ts\n2. Import the SnapshotActionHandler class from '../handlers/snapshot-action.handler'\n3. Import ActionType enum from '../dto/action-config.dto' if not already imported\n4. Locate the ActionHandlerFactory class constructor\n5. Inject SnapshotActionHandler as a dependency in the constructor parameters (e.g., private readonly snapshotActionHandler: SnapshotActionHandler)\n6. Within the constructor body, find where action handlers are registered to the internal handler map/registry\n7. Add a new registration entry mapping ActionType.SNAPSHOT to the snapshotActionHandler instance\n8. Follow the existing pattern used for other action handlers (e.g., this.handlers.set(ActionType.SNAPSHOT, this.snapshotActionHandler) or similar based on the factory's implementation)\n9. Ensure the registration maintains consistency with other handler registrations in terms of formatting and structure\n10. Verify that the ActionHandlerFactory module properly provides SnapshotActionHandler in its module dependencies\n11. Check if any additional configuration or initialization is needed for the handler registration",
        "testStrategy": "1. Create unit tests in action-handler.factory.spec.ts:\n   a. Mock SnapshotActionHandler and verify it's injected into the factory constructor\n   b. Test that getHandler(ActionType.SNAPSHOT) returns the SnapshotActionHandler instance\n   c. Verify the handler is properly registered in the factory's internal map\n2. Create integration tests:\n   a. Instantiate ActionHandlerFactory with all dependencies including SnapshotActionHandler\n   b. Request a handler for ActionType.SNAPSHOT and verify it returns the correct handler type\n   c. Test that the returned handler has the expected execute method\n3. Test backward compatibility:\n   a. Verify existing action type registrations still work correctly\n   b. Ensure no existing handler registrations are affected by the new addition\n4. Test error handling:\n   a. Verify appropriate behavior if SnapshotActionHandler fails to inject\n5. Run the full test suite to ensure no regressions in the factory or related modules",
        "status": "done",
        "dependencies": [
          2,
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Register SnapshotActionHandler as a provider in JobsModule",
        "description": "Update the JobsModule to include SnapshotActionHandler in the providers array, ensuring it's available for dependency injection throughout the jobs module and can be properly instantiated by the ActionHandlerFactory.",
        "details": "1. Open the file src/modules/jobs/jobs.module.ts\n2. Import the SnapshotActionHandler class from './handlers/snapshot-action.handler'\n3. Locate the @Module decorator and find the 'providers' array\n4. Add SnapshotActionHandler to the providers array, maintaining alphabetical order or grouping it with other action handlers\n5. Verify that any services required by SnapshotActionHandler (such as JobArtifactService) are also registered as providers in the module\n6. If JobsModule exports providers, consider whether SnapshotActionHandler should be added to the 'exports' array (typically not needed if only used internally)\n7. Ensure the module imports any necessary modules that SnapshotActionHandler depends on (e.g., if it uses services from other modules)\n8. Check that the ActionHandlerFactory is also in the providers array so it can inject SnapshotActionHandler\n9. Verify the module structure follows NestJS best practices for provider registration\n10. Save the file and ensure no circular dependency issues are introduced",
        "testStrategy": "1. Verify the module compiles without errors after adding the provider\n2. Create an integration test that bootstraps the JobsModule and verifies SnapshotActionHandler can be resolved from the dependency injection container\n3. Test that ActionHandlerFactory can successfully inject and use SnapshotActionHandler\n4. Run the NestJS application in development mode and check for any module initialization errors in the logs\n5. Use NestJS testing utilities to create a test module and verify SnapshotActionHandler is properly instantiated with all its dependencies\n6. Verify that calling getHandler(ActionType.SNAPSHOT) from ActionHandlerFactory returns a valid SnapshotActionHandler instance\n7. Run all existing JobsModule tests to ensure no regressions were introduced\n8. Check that the module's dependency graph is correct using NestJS CLI or debugging tools",
        "status": "done",
        "dependencies": [
          4,
          5
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create comprehensive unit tests for SnapshotActionHandler",
        "description": "Develop a complete test suite for the SnapshotActionHandler class in src/modules/jobs/handlers/snapshot-action.handler.spec.ts, covering all configuration combinations, error handling scenarios, metadata capture functionality, and artifact creation, targeting over 80% code coverage.",
        "details": "1. Create the test file src/modules/jobs/handlers/snapshot-action.handler.spec.ts\n2. Import testing utilities: Test, TestingModule from @nestjs/testing, mock utilities from jest\n3. Import the SnapshotActionHandler class and all its dependencies (JobArtifactService, Logger, ActionType, ArtifactType, SnapshotConfigDto)\n4. Set up test suite with beforeEach hook to create a testing module with mocked dependencies:\n   - Mock JobArtifactService with jest.fn() for save method\n   - Mock Logger with jest.fn() for log, error, warn methods\n   - Mock Puppeteer Page object with all required methods: content(), url(), title(), cookies(), evaluate()\n5. Create test cases for basic functionality:\n   - Test that execute method is defined and callable\n   - Test HTML content capture using page.content()\n   - Test URL capture using page.url()\n   - Test page title capture using page.title()\n6. Create test cases for configuration combinations:\n   - Test with cookies enabled (cookies: true) - verify page.cookies() is called\n   - Test with cookies disabled (cookies: false) - verify page.cookies() is not called\n   - Test with localStorage enabled (localStorage: true) - verify page.evaluate() is called with localStorage access\n   - Test with localStorage disabled (localStorage: false) - verify localStorage is not captured\n   - Test with sessionStorage enabled (sessionStorage: true) - verify page.evaluate() is called with sessionStorage access\n   - Test with sessionStorage disabled (sessionStorage: false) - verify sessionStorage is not captured\n   - Test with all options enabled simultaneously\n   - Test with all options disabled\n   - Test with mixed configurations (e.g., cookies and localStorage enabled, sessionStorage disabled)\n7. Create test cases for error handling:\n   - Test behavior when page.content() throws an error\n   - Test behavior when page.cookies() throws an error\n   - Test behavior when page.evaluate() throws an error for localStorage/sessionStorage\n   - Test behavior when JobArtifactService.save() fails\n   - Test handling of null or undefined page object\n   - Test handling of invalid configuration objects\n8. Create test cases for metadata capture:\n   - Verify timestamp is captured and formatted correctly\n   - Verify user agent is captured from page context\n   - Verify viewport dimensions are captured\n   - Verify all metadata fields are included in the final artifact\n9. Create test cases for artifact creation:\n   - Verify JobArtifactService.save() is called with correct parameters\n   - Verify artifact type is set to ArtifactType.SNAPSHOT\n   - Verify artifact data is properly formatted as JSON\n   - Verify artifact includes all captured data (HTML, metadata, optional storage data)\n   - Verify artifact filename follows expected naming convention\n10. Add integration-style tests:\n    - Test complete execution flow from start to finish\n    - Verify the handler returns expected result structure\n11. Use code coverage tools (jest --coverage) to measure coverage and identify untested code paths\n12. Add edge case tests for boundary conditions and unusual inputs",
        "testStrategy": "1. Run the test suite with jest and verify all tests pass: npm test snapshot-action.handler.spec.ts\n2. Generate code coverage report: npm test -- --coverage snapshot-action.handler.spec.ts\n3. Verify code coverage exceeds 80% threshold for:\n   - Statement coverage\n   - Branch coverage\n   - Function coverage\n   - Line coverage\n4. Review coverage report to identify any untested code paths and add additional tests if needed\n5. Verify all mocks are properly configured and called with expected arguments using jest assertions:\n   - expect(mockService.method).toHaveBeenCalledWith(expectedArgs)\n   - expect(mockService.method).toHaveBeenCalledTimes(expectedCount)\n6. Test that error scenarios properly throw or handle exceptions\n7. Verify test isolation - each test should be independent and not affect others\n8. Run tests multiple times to ensure consistency and no flaky tests\n9. Verify that all configuration combinations are tested with appropriate assertions\n10. Check that test descriptions clearly indicate what is being tested\n11. Ensure tests follow AAA pattern (Arrange, Act, Assert) for clarity\n12. Validate that async operations are properly handled with async/await or done callbacks",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create comprehensive integration tests for snapshot action in test/snapshot-action.e2e-spec.ts",
        "description": "Develop end-to-end integration tests for the snapshot action functionality, covering single and multiple snapshots, artifact creation and retrieval, all optional configuration features (cookies, localStorage, sessionStorage), and snapshots captured after page interactions.",
        "details": "1. Create the test file test/snapshot-action.e2e-spec.ts in the test directory\n2. Import necessary testing utilities: Test, TestingModule from @nestjs/testing, INestApplication from @nestjs/common\n3. Import required modules and services: AppModule, JobsService, JobArtifactService, ActionType, ArtifactType\n4. Import supertest for HTTP request testing and puppeteer types if needed for validation\n5. Set up test suite with beforeAll hook to:\n   - Create a testing module using Test.createTestingModule with AppModule\n   - Compile the module and create the NestJS application instance\n   - Initialize the application with app.init()\n   - Set up test database connection or use in-memory database\n6. Set up afterAll hook to close the application and clean up resources\n7. Implement test case: 'should create a single snapshot with HTML content and metadata'\n   - Create a job with a single snapshot action using POST /jobs endpoint\n   - Execute the job and wait for completion\n   - Retrieve the job artifacts using GET /jobs/:id/artifacts\n   - Verify artifact type is SNAPSHOT\n   - Parse the artifact content JSON and validate it contains: html, url, title, timestamp fields\n   - Verify HTML content is not empty and contains expected structure\n8. Implement test case: 'should create multiple snapshots in sequence'\n   - Create a job with multiple snapshot actions (2-3 snapshots)\n   - Execute the job and verify all snapshots are created\n   - Retrieve all artifacts and verify count matches expected number\n   - Verify each artifact has unique content and proper sequencing\n9. Implement test case: 'should capture cookies when cookies option is enabled'\n   - Create a job with snapshot action where config.snapshot.cookies = true\n   - Set up a test page with cookies using a navigate action first\n   - Execute snapshot action\n   - Retrieve artifact and verify the JSON contains a 'cookies' array with cookie data\n   - Validate cookie structure includes name, value, domain fields\n10. Implement test case: 'should not capture cookies when cookies option is disabled or omitted'\n    - Create job with snapshot action where config.snapshot.cookies = false or undefined\n    - Execute the job\n    - Verify artifact JSON does not contain 'cookies' field or it's null/empty\n11. Implement test case: 'should capture localStorage when localStorage option is enabled'\n    - Create job with navigate action to set localStorage items, then snapshot with config.snapshot.localStorage = true\n    - Execute the job\n    - Verify artifact contains 'localStorage' object with key-value pairs\n12. Implement test case: 'should capture sessionStorage when sessionStorage option is enabled'\n    - Create job with navigate action to set sessionStorage items, then snapshot with config.snapshot.sessionStorage = true\n    - Execute the job\n    - Verify artifact contains 'sessionStorage' object with key-value pairs\n13. Implement test case: 'should capture all storage types when all options are enabled'\n    - Create job with snapshot action where all options (cookies, localStorage, sessionStorage) are true\n    - Set up test page with all storage types populated\n    - Verify artifact contains all three storage types with correct data\n14. Implement test case: 'should capture snapshot after page interactions'\n    - Create job with sequence: navigate -> click action -> type action -> snapshot\n    - Execute job and verify snapshot captures the modified page state\n    - Verify HTML content reflects the interactions (e.g., form filled, elements clicked)\n15. Implement test case: 'should retrieve snapshot artifacts by job ID'\n    - Create and execute a job with snapshot actions\n    - Use GET /jobs/:id/artifacts endpoint to retrieve artifacts\n    - Filter artifacts by type SNAPSHOT\n    - Verify all snapshot artifacts are returned with correct metadata\n16. Add helper functions for common operations:\n    - createJobWithSnapshot(config): creates a job with snapshot action\n    - executeAndWaitForJob(jobId): executes job and polls until completion\n    - getSnapshotArtifacts(jobId): retrieves and filters snapshot artifacts\n    - parseSnapshotContent(artifact): parses JSON content from artifact\n17. Add cleanup in afterEach hook to delete test jobs and artifacts",
        "testStrategy": "1. Run the e2e test suite with npm run test:e2e snapshot-action.e2e-spec.ts and verify all tests pass\n2. Verify test coverage for integration scenarios:\n   - Single snapshot creation and retrieval\n   - Multiple snapshots in one job\n   - Each optional feature (cookies, localStorage, sessionStorage) individually\n   - All optional features combined\n   - Snapshots after page interactions\n3. Test with real browser instance (Chromium via Puppeteer) to ensure actual browser state capture works\n4. Verify artifacts are properly stored in the database and retrievable via API\n5. Test error scenarios:\n   - Invalid snapshot configuration\n   - Snapshot on non-existent page\n   - Snapshot before navigation\n6. Validate JSON structure of snapshot artifacts matches expected schema\n7. Verify timestamps are accurate and metadata is complete\n8. Test artifact cleanup and deletion\n9. Run tests in CI/CD pipeline to ensure consistency across environments\n10. Verify no memory leaks or resource issues when creating multiple snapshots\n11. Test concurrent snapshot operations if applicable\n12. Validate that snapshot content is properly escaped and sanitized in JSON format",
        "status": "done",
        "dependencies": [
          4,
          5,
          6,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Update README.md to add snapshot action to available actions list and include usage examples with configuration options",
        "description": "Update the project's README.md documentation to include the new SNAPSHOT action type in the available actions list and provide comprehensive usage examples demonstrating all configuration options including cookies, localStorage, and sessionStorage capture.",
        "details": "1. Open the README.md file in the project root directory\n2. Locate the section that lists available action types (likely under 'Available Actions', 'Action Types', or 'Features' heading)\n3. Add SNAPSHOT to the list of action types with a brief description: 'SNAPSHOT - Captures the current state of a web page including HTML content, metadata, and optionally cookies, localStorage, and sessionStorage'\n4. Create or locate the 'Usage Examples' or 'Configuration' section\n5. Add a new subsection titled 'Snapshot Action' or 'Taking Page Snapshots'\n6. Include a basic example showing minimal snapshot configuration:\n   ```json\n   {\n     \"type\": \"SNAPSHOT\"\n   }\n   ```\n7. Add an advanced example demonstrating all optional configuration fields:\n   ```json\n   {\n     \"type\": \"SNAPSHOT\",\n     \"snapshot\": {\n       \"cookies\": true,\n       \"localStorage\": true,\n       \"sessionStorage\": true\n     }\n   }\n   ```\n8. Document what data is captured by default (HTML content, URL, title, timestamp)\n9. Explain each optional configuration field:\n   - cookies: When true, captures all browser cookies for the current domain\n   - localStorage: When true, captures all localStorage key-value pairs\n   - sessionStorage: When true, captures all sessionStorage key-value pairs\n10. Add a note about artifact storage: 'Snapshot data is saved as a JSON artifact that can be retrieved via the artifacts API endpoint'\n11. Include an example of a complete job configuration with snapshot actions:\n    ```json\n    {\n      \"url\": \"https://example.com\",\n      \"actions\": [\n        {\"type\": \"NAVIGATE\"},\n        {\"type\": \"WAIT\", \"wait\": {\"duration\": 2000}},\n        {\n          \"type\": \"SNAPSHOT\",\n          \"snapshot\": {\n            \"cookies\": true,\n            \"localStorage\": true\n          }\n        }\n      ]\n    }\n    ```\n12. Add information about retrieving snapshot artifacts, including the artifact type (SNAPSHOT) and expected JSON structure\n13. Review formatting, ensure consistent markdown styling with the rest of the README\n14. Add any relevant cross-references to API documentation or related features",
        "testStrategy": "1. Review the updated README.md to verify all sections are present:\n   - SNAPSHOT is listed in the available actions section\n   - Basic usage example is included and syntactically correct\n   - Advanced usage example with all configuration options is included\n   - Each configuration option is documented with clear explanations\n2. Validate all JSON examples are properly formatted and valid JSON:\n   - Copy each example and validate using a JSON validator\n   - Ensure proper escaping and quotation marks\n3. Verify markdown rendering:\n   - Preview the README.md in a markdown viewer or on GitHub\n   - Check that code blocks render correctly with syntax highlighting\n   - Verify headings, lists, and formatting are consistent\n4. Cross-reference with implementation:\n   - Compare documented configuration options with SnapshotConfigDto fields (Task 3)\n   - Verify action type name matches ActionType enum (Task 2)\n   - Ensure artifact type mentioned matches ArtifactType enum (Task 1)\n5. Test example configurations:\n   - Use the documented examples in actual API requests to verify they work\n   - Confirm the examples produce expected results\n6. Review for completeness:\n   - Verify all optional fields are documented\n   - Check that default behavior is clearly explained\n   - Ensure artifact retrieval information is accurate\n7. Peer review the documentation for clarity, accuracy, and completeness",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Update API documentation in docs/tech/05-api-reference.md to include snapshot action documentation section",
        "description": "Add comprehensive API reference documentation for the SNAPSHOT action type, including configuration schema, request/response examples, and detailed descriptions of all snapshot configuration options (cookies, localStorage, sessionStorage).",
        "details": "1. Open the file docs/tech/05-api-reference.md\n2. Locate the section documenting action types or create a new 'Action Types' section if it doesn't exist\n3. Add a new subsection titled 'SNAPSHOT Action' with the following structure:\n   - Overview: Brief description of what the SNAPSHOT action does (captures browser state including HTML, metadata, and optional storage data)\n   - Action Type Value: Document that the type field should be set to 'SNAPSHOT'\n4. Document the configuration schema for SnapshotConfigDto:\n   - Create a 'Configuration Options' subsection\n   - Document the 'cookies' field: type (boolean), optional, default behavior, description of what data is captured when enabled\n   - Document the 'localStorage' field: type (boolean), optional, default behavior, description of what data is captured when enabled\n   - Document the 'sessionStorage' field: type (boolean), optional, default behavior, description of what data is captured when enabled\n5. Add a 'Request Example' subsection showing a complete job configuration JSON with a SNAPSHOT action:\n   - Include basic example with no optional fields\n   - Include advanced example with all optional fields enabled\n   - Show proper JSON structure and formatting\n6. Add a 'Response/Artifact Structure' subsection:\n   - Document the artifact type (SNAPSHOT)\n   - Describe the JSON structure of the saved snapshot artifact\n   - Include example of captured data structure with fields: html, url, title, timestamp, cookies (if enabled), localStorage (if enabled), sessionStorage (if enabled)\n7. Add a 'Use Cases' subsection with practical examples:\n   - Capturing page state for debugging\n   - Preserving authentication state with cookies\n   - Archiving application state with storage data\n8. Add any relevant notes about browser compatibility, security considerations, or performance implications\n9. Ensure consistent formatting with existing documentation sections (headings, code blocks, tables)\n10. Add cross-references to related documentation sections if applicable",
        "testStrategy": "1. Review the updated documentation for completeness:\n   - Verify SNAPSHOT action is documented with clear overview\n   - Confirm all three configuration options (cookies, localStorage, sessionStorage) are documented with types and descriptions\n   - Check that both basic and advanced request examples are present and syntactically valid JSON\n   - Verify artifact structure documentation matches actual implementation\n2. Validate JSON examples by copying them and verifying they parse correctly\n3. Cross-reference documentation against actual implementation:\n   - Compare documented configuration fields with SnapshotConfigDto class definition\n   - Verify documented artifact structure matches what SnapshotActionHandler produces\n   - Confirm action type value matches ActionType enum\n4. Review documentation for clarity and completeness:\n   - Ensure technical terms are explained or linked to definitions\n   - Verify examples are realistic and helpful\n   - Check that formatting is consistent with other sections\n5. Have a team member review the documentation for accuracy and usability\n6. Test that documentation renders correctly if using a documentation generator or markdown viewer",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Update technical documentation in docs/tech/07-browser-pool-actions.md to add snapshot handler documentation following existing patterns",
        "description": "Add comprehensive technical documentation for the SnapshotActionHandler to the browser pool actions technical documentation file, following the established documentation patterns and structure used for other action handlers.",
        "details": "1. Open the file docs/tech/07-browser-pool-actions.md\n2. Review the existing documentation structure and patterns used for other action handlers to maintain consistency\n3. Add a new section titled 'SnapshotActionHandler' positioned appropriately among other handler documentation\n4. Document the handler's purpose: Captures the current state of a web page including HTML content, metadata (URL, title, timestamp), and optionally cookies, localStorage, and sessionStorage\n5. Document the class structure:\n   - Class name: SnapshotActionHandler\n   - Location: src/modules/jobs/handlers/snapshot-action.handler.ts\n   - Dependencies: JobArtifactService, Logger\n   - Implements: ActionHandler interface\n6. Document the execute method signature and parameters:\n   - Method: async execute(page: Page, config: ActionConfigDto, jobId: number): Promise<void>\n   - page: Puppeteer Page instance representing the browser page\n   - config: ActionConfigDto containing snapshot configuration options\n   - jobId: Identifier for the job to associate artifacts with\n7. Document configuration options from SnapshotConfigDto:\n   - cookies (boolean, optional): Whether to capture browser cookies\n   - localStorage (boolean, optional): Whether to capture localStorage data\n   - sessionStorage (boolean, optional): Whether to capture sessionStorage data\n8. Document the snapshot data structure that gets saved as an artifact:\n   - html: string (page HTML content)\n   - url: string (current page URL)\n   - title: string (page title)\n   - timestamp: string (ISO format capture time)\n   - cookies: array (if enabled)\n   - localStorage: object (if enabled)\n   - sessionStorage: object (if enabled)\n9. Document the artifact creation:\n   - ArtifactType: SNAPSHOT\n   - Content-Type: application/json\n   - Data format: JSON stringified snapshot object\n10. Add code examples showing typical usage patterns:\n    - Basic snapshot without optional features\n    - Snapshot with all optional features enabled\n11. Document error handling and edge cases:\n    - Handling pages without localStorage/sessionStorage support\n    - Cookie capture failures\n    - Large data handling considerations\n12. Add notes about integration with ActionHandlerFactory and registration in JobsModule\n13. Include cross-references to related documentation sections (ActionType enum, ArtifactType enum, API reference)\n14. Ensure all code examples use proper syntax highlighting and formatting consistent with the rest of the document",
        "testStrategy": "1. Review the updated documentation for completeness:\n   - Verify SnapshotActionHandler section is present and properly formatted\n   - Confirm class structure documentation includes all key components\n   - Check that execute method signature is accurately documented\n   - Verify all three configuration options are documented with types and descriptions\n2. Validate documentation accuracy:\n   - Cross-reference documented class structure with actual implementation in src/modules/jobs/handlers/snapshot-action.handler.ts\n   - Verify configuration options match SnapshotConfigDto definition\n   - Confirm snapshot data structure matches actual artifact content\n   - Check that artifact type and content-type are correctly documented\n3. Check consistency with existing patterns:\n   - Compare formatting and structure with other action handler documentation in the same file\n   - Verify section headings follow the same hierarchy and naming conventions\n   - Confirm code examples use the same syntax highlighting and formatting style\n   - Check that cross-references use the same linking format as other sections\n4. Validate code examples:\n   - Ensure all code examples are syntactically correct\n   - Verify examples demonstrate both basic and advanced usage\n   - Check that configuration objects in examples match the documented schema\n5. Test documentation usability:\n   - Have a developer unfamiliar with the implementation read the documentation and verify they understand how to use the handler\n   - Confirm all technical terms are either defined or linked to definitions\n   - Verify the documentation provides enough detail for maintenance and troubleshooting",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Fix JobsService test suite - add missing ArtifactStorageService mock provider",
        "description": "Add the missing ArtifactStorageService mock provider to the TestingModule setup in src/modules/jobs/jobs.service.spec.ts to resolve dependency injection errors causing all 10 tests to fail.",
        "details": "1. Open the test file src/modules/jobs/jobs.service.spec.ts\n2. Locate the TestingModule.createTestingModule() setup in the beforeEach hook\n3. Review the existing mock providers pattern used for BrowsersService and JobEventsGateway to understand the mocking approach\n4. Add a mock provider for ArtifactStorageService following the same pattern:\n   - Create a mockArtifactStorageService object with jest.fn() mocked methods for all public methods used by JobsService\n   - Common methods to mock might include: save, get, delete, list, or similar storage operations\n5. Add the provider to the providers array in the format:\n   {\n     provide: ArtifactStorageService,\n     useValue: mockArtifactStorageService\n   }\n6. Ensure the mock is properly reset in beforeEach if needed (mockArtifactStorageService.methodName.mockClear())\n7. Import ArtifactStorageService at the top of the file if not already imported\n8. Verify that all method calls to ArtifactStorageService in the tests have corresponding mock implementations\n9. Review each of the 10 failing tests to ensure they don't require specific mock return values or behaviors from ArtifactStorageService\n10. Add any necessary mock return values using mockResolvedValue() or mockReturnValue() for methods that need specific responses",
        "testStrategy": "1. Run the test suite: npm test jobs.service.spec.ts\n2. Verify all 10 tests now pass without dependency injection errors\n3. Check the test output for any remaining errors related to ArtifactStorageService\n4. Verify that the mock provider is properly instantiated by adding a test that checks mock method calls if needed\n5. Run the entire test suite to ensure no regressions: npm test\n6. Confirm test coverage remains stable or improves for the JobsService\n7. Verify that mock methods are being called as expected in tests that interact with artifact storage functionality\n8. Check that the mock follows the same pattern and style as other service mocks in the file for consistency",
        "status": "done",
        "dependencies": [
          4,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Fix NativeRecaptchaSolver test failures - implement missing sleep method",
        "description": "Add a private sleep method to the NativeRecaptchaSolver class to resolve test failures caused by calls to this.sleep() at multiple locations (lines 555, 691, 794, 1041, 1086, 1102, 1116) where the method doesn't exist, and update tests to properly mock or handle the sleep functionality.",
        "details": "1. Locate the NativeRecaptchaSolver class file (likely in src/modules/captcha/ or similar directory)\n2. Review all seven locations where this.sleep() is called (lines 555, 691, 794, 1041, 1086, 1102, 1116) to understand the expected behavior and parameters\n3. Add a private sleep method to the class with the following implementation:\n   private sleep(milliseconds: number): Promise<void> {\n     return new Promise(resolve => setTimeout(resolve, milliseconds));\n   }\n4. Alternatively, consider creating a shared utility function if sleep is needed across multiple classes:\n   - Create src/common/utils/sleep.util.ts with export function sleep(ms: number): Promise<void>\n   - Import and use the utility function instead of a class method\n5. Verify that all seven call sites use consistent parameter types (milliseconds as number)\n6. Update the corresponding test file (likely native-recaptcha-solver.spec.ts):\n   - Mock the sleep method using jest.spyOn() or jest.fn()\n   - Use jest.useFakeTimers() and jest.advanceTimersByTime() to control time in tests\n   - Ensure tests don't actually wait for real delays, making them fast and deterministic\n7. Add test cases specifically for the sleep method behavior if implementing as a utility\n8. Review test failures to ensure all four failing tests are addressed by the implementation",
        "testStrategy": "1. Run the NativeRecaptchaSolver test suite and verify all four previously failing tests now pass\n2. Verify the sleep method is properly defined and returns a Promise<void>\n3. Test that sleep method resolves after the specified delay using jest.useFakeTimers():\n   - Call sleep(1000) and advance timers by 1000ms\n   - Verify the promise resolves correctly\n4. Verify all seven call sites (lines 555, 691, 794, 1041, 1086, 1102, 1116) execute without errors\n5. Run tests with jest.useFakeTimers() to ensure tests complete quickly without actual delays\n6. Verify mock implementations in tests properly stub the sleep method\n7. Check test coverage to ensure the sleep method and all call sites are covered\n8. Run the full test suite to ensure no regressions in other tests",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Fix JobEventsGateway test failure - handle undefined client in handlePong test",
        "description": "Resolve the TypeError in job-events.gateway.spec.ts at line 219 where the test attempts to access gateway['clients'].get('socket-id-123').lastPong without ensuring the client exists. Update the test setup to properly initialize the client before accessing its properties or add appropriate null/undefined checks.",
        "details": "1. Open the test file src/modules/jobs/gateways/job-events.gateway.spec.ts\n2. Locate the test case at line 219 that tests the handlePong functionality\n3. Review the test setup (beforeEach or within the specific test) to understand how the clients Map is initialized\n4. Identify the issue: The test calls gateway['clients'].get('socket-id-123').lastPong but the client with ID 'socket-id-123' may not be properly added to the clients Map\n5. Implement one of the following solutions:\n   Option A - Initialize client in test setup:\n   - Before accessing the client, add it to the clients Map: gateway['clients'].set('socket-id-123', { id: 'socket-id-123', lastPong: Date.now(), socket: mockSocket })\n   - Ensure the mock client object has all required properties (id, lastPong, socket)\n   Option B - Add null checks in the test:\n   - Modify the test to check if the client exists before accessing properties: const client = gateway['clients'].get('socket-id-123'); expect(client).toBeDefined(); expect(client.lastPong).toBeDefined();\n6. Review other tests in the same file to ensure consistent client initialization patterns\n7. Consider if the handlePong method itself needs null checks (review the implementation in job-events.gateway.ts)\n8. If the gateway implementation lacks null checks, add defensive programming: const client = this.clients.get(socketId); if (!client) return; client.lastPong = Date.now();\n9. Verify the mock socket object used in tests has all necessary properties that handlePong might access",
        "testStrategy": "1. Run the specific failing test: npm test -- job-events.gateway.spec.ts -t 'handlePong'\n2. Verify the test at line 219 now passes without TypeError\n3. Run the entire JobEventsGateway test suite to ensure no regressions: npm test job-events.gateway.spec.ts\n4. Verify all tests pass and no new failures are introduced\n5. Test the actual handlePong implementation with various scenarios:\n   - Test with a valid client ID that exists in the clients Map\n   - Test with an invalid/non-existent client ID to ensure graceful handling\n   - Test that lastPong timestamp is properly updated when client exists\n6. Add additional test cases if needed:\n   - Test handlePong with undefined client ID\n   - Test handlePong with null client ID\n   - Test handlePong updates lastPong to current timestamp\n7. Review code coverage to ensure the handlePong method and its edge cases are adequately tested\n8. Perform manual testing if applicable by connecting a WebSocket client and verifying pong handling works correctly",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Handle Playwright browser installation requirement in StealthService tests",
        "description": "Add proper test setup to check for Playwright browser availability in stealth.service.spec.ts and skip tests gracefully when browsers are not installed, preventing test failures due to missing browser binaries. Include documentation for running browser installation commands.",
        "details": "1. Open the test file src/modules/stealth/stealth.service.spec.ts\n2. Add a beforeAll hook at the top of the test suite to check for Playwright browser availability:\n   - Import playwright from '@playwright/test' or 'playwright'\n   - Create an async function to check if browsers are installed by attempting to launch a browser with a timeout\n   - Use a try-catch block to detect if browsers are missing (typically throws an error about executable not found)\n3. Implement graceful test skipping:\n   - Set a suite-level variable (e.g., browsersAvailable: boolean) based on the check result\n   - Use beforeEach or individual test conditionals to skip tests when browsersAvailable is false\n   - Alternatively, use jest.describe.skip() to skip the entire suite if browsers are not available\n4. Add informative console warnings when tests are skipped:\n   - Log a clear message: 'Skipping StealthService tests: Playwright browsers not installed. Run: npx playwright install'\n5. Create or update test documentation:\n   - Add a comment block at the top of the test file explaining the browser requirement\n   - Update the project's test README or contributing guide with instructions to run 'npx playwright install' before running tests\n6. Consider adding a package.json script for test setup:\n   - Add a 'test:setup' script that runs 'npx playwright install'\n   - Update CI/CD configuration to run browser installation before tests\n7. Handle the three specific failing tests by ensuring they check browser availability before execution\n8. Add error handling for browser launch failures that provides actionable error messages",
        "testStrategy": "1. Run the StealthService test suite without Playwright browsers installed and verify:\n   - Tests are skipped gracefully with informative messages\n   - No test failures occur due to missing browsers\n   - The skip message includes the installation command\n2. Run 'npx playwright install' and verify:\n   - All three previously failing tests now execute successfully\n   - Browser availability check passes in beforeAll hook\n   - Tests run without any browser-related errors\n3. Test the beforeAll hook logic:\n   - Mock browser availability check to return false and verify tests are skipped\n   - Mock browser availability check to return true and verify tests execute\n4. Verify documentation updates:\n   - Check that test file comments clearly explain browser requirements\n   - Confirm README or contributing guide includes browser installation instructions\n5. Run the entire test suite to ensure no regressions in other tests\n6. Test in CI/CD environment to ensure browser installation step is properly configured",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-17T21:44:40.857Z",
      "description": "Default tasks context",
      "updated": "2025-11-18T09:41:53.001Z"
    }
  }
}