{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Fix Test Failures in confidence-scoring.service.spec.ts",
        "description": "Resolve dependency injection issues and ensure all tests in the captcha-solver module pass to unblock CI/CD pipeline",
        "details": "1. Analyze the failing test file confidence-scoring.service.spec.ts\n2. Identify dependency injection issues - likely missing providers or incorrect mock setup\n3. Update TestingModule configuration with proper providers:\n   - Add all required dependencies to providers array\n   - Mock external dependencies appropriately\n   - Ensure proper injection tokens are used\n4. Fix any assertion errors or timing issues\n5. Run tests locally: npm test captcha-solver\n6. Verify test coverage is maintained or improved\n7. Ensure no regression in other test files",
        "testStrategy": "Run full test suite with 'npm test' and verify all tests pass. Check coverage report to ensure no decrease in coverage percentage. Run tests in CI environment to confirm pipeline unblocking.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Custom Exception Hierarchy Base Classes",
        "description": "Implement base CaptchaSolverException class with error codes, categories, and recovery flags",
        "details": "1. Create src/captcha-solver/exceptions/captcha-solver.exception.ts\n2. Define error categories enum:\n   enum ErrorCategory { AVAILABILITY = 'AVAILABILITY', VALIDATION = 'VALIDATION', NETWORK = 'NETWORK', PROVIDER = 'PROVIDER', INTERNAL = 'INTERNAL' }\n3. Implement base class:\n   export class CaptchaSolverException extends Error {\n     constructor(\n       message: string,\n       public readonly code: string,\n       public readonly category: ErrorCategory,\n       public readonly isRecoverable: boolean = false,\n       public readonly context?: Record<string, any>\n     ) {\n       super(message);\n       this.name = this.constructor.name;\n       Error.captureStackTrace(this, this.constructor);\n     }\n   }\n4. Add helper methods: toJSON(), toString()\n5. Export from index.ts",
        "testStrategy": "Create unit tests verifying exception properties are set correctly, inheritance works, stack traces are captured, and JSON serialization includes all relevant fields.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Specific Exception Classes",
        "description": "Create specific exception classes for different error scenarios: SolverUnavailableException, ProviderException, ValidationException",
        "details": "1. Create SolverUnavailableException extending CaptchaSolverException:\n   - category: ErrorCategory.AVAILABILITY\n   - isRecoverable: true\n   - Include solver type and reason\n2. Create ProviderException:\n   - category: ErrorCategory.PROVIDER\n   - isRecoverable: true\n   - Include provider name and API response\n3. Create ValidationException:\n   - category: ErrorCategory.VALIDATION\n   - isRecoverable: false\n   - Include validation errors array\n4. Create NetworkException:\n   - category: ErrorCategory.NETWORK\n   - isRecoverable: true\n5. Create InternalException:\n   - category: ErrorCategory.INTERNAL\n   - isRecoverable: false\n6. Export all from exceptions/index.ts",
        "testStrategy": "Unit tests for each exception class verifying correct category, recoverability flag, and context data. Test inheritance chain and error serialization.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Replace Generic Error Throws with Custom Exceptions",
        "description": "Audit and replace all generic Error throws throughout the captcha-solver module with appropriate custom exceptions",
        "details": "1. Search codebase for 'throw new Error' and 'throw error'\n2. Analyze each throw statement context\n3. Replace with appropriate custom exception:\n   - Solver unavailable → SolverUnavailableException\n   - Provider API errors → ProviderException\n   - Invalid input → ValidationException\n   - Network failures → NetworkException\n   - Unexpected errors → InternalException\n4. Add context data to exceptions (solver type, provider, request ID)\n5. Update error handling in catch blocks to handle custom exceptions\n6. Ensure error messages are descriptive and actionable",
        "testStrategy": "Review all error handling code paths. Create integration tests that trigger each error scenario and verify correct exception type is thrown with proper context.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Configuration Constants File",
        "description": "Extract all magic numbers and hard-coded values into a centralized configuration constants file",
        "details": "1. Create src/captcha-solver/config/constants.ts\n2. Define configuration interface:\n   export interface CaptchaSolverConfig {\n     circuitBreaker: {\n       failureThreshold: number; // default: 3\n       timeoutPeriod: number; // default: 60000ms\n     };\n     cache: {\n       ttl: number; // default: 300000ms (5 min)\n     };\n     retry: {\n       maxAttempts: number; // default: 3\n       backoffMs: number; // default: 1000\n     };\n     timeouts: {\n       solveTimeout: number; // default: 30000\n       detectionTimeout: number; // default: 5000\n     };\n   }\n3. Export default configuration object\n4. Create ConfigService to load from environment variables\n5. Replace hard-coded values throughout codebase",
        "testStrategy": "Verify all magic numbers are replaced. Test configuration loading from environment variables. Ensure default values are applied when env vars are missing.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Circuit Breaker Service",
        "description": "Create SolverCircuitBreaker service to track failures and temporarily disable failing solvers",
        "details": "1. Create src/captcha-solver/services/solver-circuit-breaker.service.ts\n2. Implement circuit breaker states: CLOSED, OPEN, HALF_OPEN\n3. Track per-solver state:\n   private solverStates = new Map<string, {\n     state: CircuitState;\n     consecutiveFailures: number;\n     lastFailureTime: number;\n     nextAttemptTime: number;\n   }>();\n4. Implement methods:\n   - recordSuccess(solverType: string): void\n   - recordFailure(solverType: string): void\n   - isAvailable(solverType: string): boolean\n   - reset(solverType: string): void\n5. Use configuration for thresholds and timeouts\n6. Add logging for state transitions\n7. Implement automatic recovery after timeout period",
        "testStrategy": "Unit tests for state transitions, failure counting, timeout behavior, and recovery. Test concurrent access scenarios. Verify proper integration with configuration service.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Integrate Circuit Breaker with SolverRegistry",
        "description": "Integrate SolverCircuitBreaker with SolverRegistry to check solver availability before selection",
        "details": "1. Inject SolverCircuitBreaker into SolverRegistry\n2. Modify getAvailableSolvers() method:\n   - Filter out solvers where circuitBreaker.isAvailable() returns false\n   - Log when solvers are excluded due to circuit breaker\n3. Update selectBestSolver() to skip unavailable solvers\n4. Add method to get all solvers including unavailable ones for monitoring\n5. Update health check to report circuit breaker states\n6. Ensure proper error handling when no solvers are available",
        "testStrategy": "Integration tests verifying solvers are excluded when circuit is open. Test that solvers become available again after timeout. Verify health check reports circuit breaker status.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate Circuit Breaker with SolverFactory",
        "description": "Update SolverFactory to record successes and failures with circuit breaker",
        "details": "1. Inject SolverCircuitBreaker into SolverFactory\n2. Wrap solver execution in try-catch:\n   try {\n     const result = await solver.solve(captcha);\n     circuitBreaker.recordSuccess(solverType);\n     return result;\n   } catch (error) {\n     circuitBreaker.recordFailure(solverType);\n     throw error;\n   }\n3. Add correlation ID to track requests\n4. Log circuit breaker state changes\n5. Update error messages to indicate if solver is circuit-broken",
        "testStrategy": "Integration tests simulating solver failures and verifying circuit breaker records them. Test that successful solves reset failure count. Verify proper error propagation.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Refactor SolverFactory.createSolver() with Strategy Pattern",
        "description": "Replace complex conditional logic in createSolver() method with strategy map pattern",
        "details": "1. Create solver configuration map:\n   private readonly solverStrategies = new Map<CaptchaType, SolverCreationStrategy>([\n     [CaptchaType.RECAPTCHA_V2, () => this.create2CaptchaSolver()],\n     [CaptchaType.RECAPTCHA_V3, () => this.createRecaptchaV3Solver()],\n     [CaptchaType.HCAPTCHA, () => this.createHCaptchaSolver()],\n     // ... other types\n   ]);\n2. Simplify createSolver() method:\n   const strategy = this.solverStrategies.get(type);\n   if (!strategy) throw new ValidationException(`Unsupported captcha type: ${type}`);\n   return strategy();\n3. Extract individual solver creation methods\n4. Make adding new solver types require only adding to map\n5. Remove lines 38-81 complex if-else chain",
        "testStrategy": "Unit tests for each solver type creation. Verify unsupported types throw ValidationException. Test that all previously supported types still work. Measure cyclomatic complexity reduction.",
        "priority": "high",
        "dependencies": [
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Parallel Solver Attempts",
        "description": "Modify solveWithFallback to try top 2-3 solvers in parallel using Promise.allSettled",
        "details": "1. Update solveWithFallback() in orchestration service\n2. Get top 3 solvers from registry based on confidence scores\n3. Filter out circuit-broken solvers\n4. Create parallel solve attempts:\n   const attempts = topSolvers.map(solver => \n     this.solveSingle(solver, captcha)\n       .catch(error => ({ error, solver }))\n   );\n   const results = await Promise.allSettled(attempts);\n5. Select first successful result\n6. If all parallel attempts fail, fall back to sequential attempts with remaining solvers\n7. Record metrics for parallel vs sequential performance\n8. Add timeout for parallel attempts (configurable)\n9. Ensure proper error aggregation",
        "testStrategy": "Integration tests with mock solvers having different response times. Verify fastest successful solver wins. Test fallback to sequential when all parallel fail. Measure performance improvement.",
        "priority": "high",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Detection Result Caching",
        "description": "Add caching layer for CAPTCHA detection results using page URL and content hash as key",
        "details": "1. Install cache-manager: npm install cache-manager\n2. Create src/captcha-solver/services/detection-cache.service.ts\n3. Implement cache key generation:\n   private generateCacheKey(url: string, contentHash: string): string {\n     return `detection:${url}:${contentHash}`;\n   }\n4. Use crypto to generate content hash from page HTML\n5. Configure TTL from constants (default 5 minutes)\n6. Implement methods:\n   - get(url: string, content: string): Promise<DetectionResult | null>\n   - set(url: string, content: string, result: DetectionResult): Promise<void>\n   - invalidate(url: string): Promise<void>\n7. Integrate with DetectionService.detectAll()\n8. Add cache hit/miss metrics\n9. Support Redis if available, fallback to in-memory",
        "testStrategy": "Unit tests for cache key generation and hash consistency. Integration tests verifying cache hits return same results. Test TTL expiration. Measure detection time improvement with cache hits.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Error Context Enrichment",
        "description": "Add correlation IDs, solver metadata, and timing information to all errors",
        "details": "1. Create correlation ID middleware/interceptor:\n   - Generate UUID for each request\n   - Store in AsyncLocalStorage or request context\n   - Add to all log messages and errors\n2. Create ErrorContext interface:\n   interface ErrorContext {\n     correlationId: string;\n     timestamp: number;\n     solverType?: string;\n     solverMetadata?: Record<string, any>;\n     timings?: { start: number; end: number; duration: number };\n     attemptNumber?: number;\n   }\n3. Update custom exceptions to include ErrorContext\n4. Create timing decorator for solver methods\n5. Implement error aggregation for multi-attempt scenarios\n6. Add structured logging with context",
        "testStrategy": "Verify correlation IDs are consistent across request lifecycle. Test that timing information is accurate. Verify error context is preserved through exception chain. Test log aggregation.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement SSRF Protection",
        "description": "Add URL validation and SSRF protection to prevent attacks through user-provided URLs",
        "details": "1. Install validator library: npm install validator\n2. Create src/captcha-solver/guards/ssrf-protection.guard.ts\n3. Implement URL validation:\n   - Validate URL format using validator.isURL()\n   - Parse URL and extract hostname\n   - Block private IP ranges: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8\n   - Block localhost, 0.0.0.0, metadata endpoints (169.254.169.254)\n   - Implement allowlist for permitted domains\n4. Create validation pipe for URL parameters\n5. Apply to all endpoints accepting URLs\n6. Add DNS resolution check to prevent DNS rebinding\n7. Log blocked attempts for security monitoring",
        "testStrategy": "Unit tests with various malicious URLs (private IPs, localhost, metadata endpoints). Test allowlist functionality. Verify legitimate URLs pass validation. Test DNS rebinding scenarios.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Secure File Handling",
        "description": "Secure temporary file creation and cleanup for screenshots and audio files with path validation",
        "details": "1. Install tmp library: npm install tmp\n2. Create src/captcha-solver/utils/secure-file-handler.ts\n3. Implement secure temp file creation:\n   - Use tmp.file() with secure options\n   - Set restrictive permissions (0600)\n   - Generate random filenames\n4. Implement automatic cleanup:\n   - Use try-finally blocks\n   - Register cleanup handlers\n   - Implement graceful shutdown cleanup\n5. Add path validation:\n   - Resolve absolute paths\n   - Ensure paths are within temp directory\n   - Prevent path traversal (../, symbolic links)\n6. Replace all fs.writeFileSync with secure handler\n7. Add file size limits",
        "testStrategy": "Unit tests for path traversal prevention. Test cleanup on success and failure. Verify file permissions. Test concurrent file operations. Verify cleanup on process termination.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Configuration Schema Validation with Joi",
        "description": "Create comprehensive Joi validation schema for all configuration options and validate on module initialization",
        "details": "1. Install Joi: npm install joi\n2. Create src/captcha-solver/config/config.schema.ts\n3. Define validation schema:\n   export const configSchema = Joi.object({\n     circuitBreaker: Joi.object({\n       failureThreshold: Joi.number().integer().min(1).max(10).default(3),\n       timeoutPeriod: Joi.number().integer().min(1000).default(60000)\n     }),\n     cache: Joi.object({\n       ttl: Joi.number().integer().min(0).default(300000)\n     }),\n     // ... other config sections\n   });\n4. Validate in module initialization:\n   const { error, value } = configSchema.validate(config);\n   if (error) throw new ValidationException('Invalid configuration', error.details);\n5. Add custom validation rules for complex constraints\n6. Provide helpful error messages",
        "testStrategy": "Unit tests with valid and invalid configurations. Test default value application. Verify helpful error messages for validation failures. Test edge cases and boundary values.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Replace 'any' Types with 'unknown' and Type Guards",
        "description": "Audit error handling code and replace catch (error: any) with catch (error: unknown) and implement type guards",
        "details": "1. Search codebase for ': any' type annotations\n2. Focus on error handling: catch (error: any)\n3. Replace with catch (error: unknown)\n4. Create type guard utilities:\n   function isError(error: unknown): error is Error {\n     return error instanceof Error;\n   }\n   function isCaptchaSolverException(error: unknown): error is CaptchaSolverException {\n     return error instanceof CaptchaSolverException;\n   }\n5. Update error handling:\n   catch (error: unknown) {\n     if (isCaptchaSolverException(error)) {\n       // handle custom exception\n     } else if (isError(error)) {\n       // handle generic error\n     } else {\n       // handle unknown error\n     }\n   }\n6. Enable strict TypeScript checks",
        "testStrategy": "Run TypeScript compiler with strict mode. Verify no 'any' types remain in error handling. Test that type guards correctly identify error types. Ensure no runtime errors from type assumptions.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Complete Swagger/OpenAPI Documentation",
        "description": "Add comprehensive Swagger documentation to all captcha-solver endpoints with examples",
        "details": "1. Add @ApiOperation decorators to all controller methods\n2. Add @ApiResponse decorators for all response codes:\n   @ApiResponse({ status: 200, description: 'Success', type: SolveResponse })\n   @ApiResponse({ status: 400, description: 'Bad Request', type: ErrorResponse })\n   @ApiResponse({ status: 500, description: 'Internal Error', type: ErrorResponse })\n3. Add @ApiProperty decorators to all DTOs with examples:\n   @ApiProperty({ example: 'https://example.com', description: 'Page URL' })\n4. Document request/response examples for each endpoint\n5. Add authentication documentation if applicable\n6. Create ErrorResponse DTO with error code, message, details\n7. Generate and review Swagger UI output",
        "testStrategy": "Review generated Swagger UI documentation. Verify all endpoints are documented. Test example requests in Swagger UI. Ensure error responses are documented with examples.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create Integration Tests for Solver Workflow",
        "description": "Add comprehensive integration tests covering full solver workflow, fallback scenarios, and error recovery",
        "details": "1. Create test/integration/solver-workflow.spec.ts\n2. Set up test environment with mock providers\n3. Test scenarios:\n   - Successful solve with first solver\n   - Fallback to second solver on first failure\n   - All solvers fail scenario\n   - Circuit breaker activation and recovery\n   - Parallel solver attempts\n   - Timeout handling\n   - Concurrent solve requests\n4. Use TestingModule with real services and mocked external dependencies\n5. Test end-to-end orchestration\n6. Verify proper error propagation and logging\n7. Test health check integration during solving",
        "testStrategy": "Run integration tests in isolated environment. Verify all scenarios pass. Measure test coverage increase. Test with different solver configurations. Verify tests are deterministic and not flaky.",
        "priority": "medium",
        "dependencies": [
          10,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Create Architecture Documentation",
        "description": "Create comprehensive architecture documentation with diagrams, component interactions, and design decisions",
        "details": "1. Create docs/architecture/ directory\n2. Create architecture overview document:\n   - System components and responsibilities\n   - Module boundaries and dependencies\n   - Data flow through the system\n3. Create component diagrams using Mermaid or PlantUML:\n   - High-level architecture diagram\n   - Solver selection flow diagram\n   - Error handling flow diagram\n   - Circuit breaker state diagram\n4. Document design patterns used:\n   - Registry pattern for solver management\n   - Factory pattern for solver creation\n   - Strategy pattern for solver selection\n   - Circuit breaker pattern for reliability\n5. Create Architecture Decision Records (ADRs) for key decisions\n6. Document extension points for adding new solvers",
        "testStrategy": "Review documentation with team members. Verify diagrams accurately represent implementation. Ensure documentation is clear and helpful for new developers. Test that examples work.",
        "priority": "medium",
        "dependencies": [
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement API Versioning and Rate Limiting",
        "description": "Add /v1/ prefix to endpoints, standardize error responses, and implement rate limiting",
        "details": "1. Update controller routes to include /v1/ prefix:\n   @Controller('v1/captcha-solver')\n2. Create standardized error response DTO:\n   class ErrorResponseDto {\n     code: string;\n     message: string;\n     details?: any;\n     timestamp: string;\n     path: string;\n   }\n3. Install throttler: npm install @nestjs/throttler\n4. Configure ThrottlerModule in module imports:\n   ThrottlerModule.forRoot({\n     ttl: 60,\n     limit: 10, // 10 requests per minute default\n   })\n5. Apply different limits per endpoint using @Throttle decorator:\n   @Throttle(5, 60) // 5 requests per minute for solve endpoint\n6. Create exception filter for standardized error responses\n7. Add rate limit headers to responses",
        "testStrategy": "Test API versioning by calling endpoints with /v1/ prefix. Test rate limiting by exceeding limits and verifying 429 responses. Verify error response format is consistent. Test different rate limits per endpoint.",
        "priority": "medium",
        "dependencies": [
          4,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Performance Monitoring with Metrics",
        "description": "Integrate Prometheus/StatsD for metrics tracking and add distributed tracing support",
        "details": "1. Install prometheus client: npm install prom-client\n2. Create src/captcha-solver/monitoring/metrics.service.ts\n3. Define metrics:\n   - Counter: captcha_solve_attempts_total (labels: type, solver, status)\n   - Histogram: captcha_solve_duration_seconds (labels: type, solver)\n   - Gauge: active_solvers (labels: type)\n   - Counter: circuit_breaker_state_changes (labels: solver, state)\n4. Instrument key operations:\n   - Solve attempts and results\n   - Detection time\n   - Cache hit/miss rates\n   - Circuit breaker state changes\n5. Create /metrics endpoint for Prometheus scraping\n6. Add OpenTelemetry for distributed tracing:\n   - Install @opentelemetry/sdk-node\n   - Create spans for solve operations\n   - Add trace context propagation\n7. Create Grafana dashboard JSON",
        "testStrategy": "Verify metrics endpoint returns valid Prometheus format. Test that metrics are incremented correctly. Verify histogram buckets are appropriate. Test trace context propagation. Load test and verify metrics accuracy.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Create Shared Utilities Module",
        "description": "Extract duplicated retry logic, error formatting, and health check patterns into shared utilities",
        "details": "1. Create src/captcha-solver/utils/ directory\n2. Create retry.util.ts:\n   export async function retryWithBackoff<T>(\n     fn: () => Promise<T>,\n     options: { maxAttempts: number; backoffMs: number; shouldRetry?: (error: unknown) => boolean }\n   ): Promise<T>\n3. Create error-formatter.util.ts:\n   - formatError(error: unknown): string\n   - formatErrorForLogging(error: unknown, context: Record<string, any>): object\n4. Create health-check.util.ts:\n   - createHealthIndicator(name: string, checkFn: () => Promise<boolean>)\n5. Replace duplicated code throughout module:\n   - Find all retry implementations\n   - Find all error formatting code\n   - Find all health check patterns\n6. Add comprehensive JSDoc comments\n7. Export from utils/index.ts",
        "testStrategy": "Unit tests for each utility function. Test retry with various failure scenarios. Test error formatting with different error types. Verify health check utilities work with NestJS health module. Measure code duplication reduction.",
        "priority": "medium",
        "dependencies": [
          4,
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Refactor DetectionService.detectAll() Method",
        "description": "Split large detectAll() method (1239 lines) into smaller, focused methods using composition",
        "details": "1. Analyze DetectionService.detectAll() method structure\n2. Extract detection strategies into separate methods:\n   - detectRecaptchaV2(): Promise<DetectionResult[]>\n   - detectRecaptchaV3(): Promise<DetectionResult[]>\n   - detectHCaptcha(): Promise<DetectionResult[]>\n   - detectCloudflare(): Promise<DetectionResult[]>\n   - detectAudioCaptcha(): Promise<DetectionResult[]>\n3. Create helper methods:\n   - parsePageContent(html: string): ParsedContent\n   - extractScripts(content: ParsedContent): Script[]\n   - analyzeScripts(scripts: Script[]): AnalysisResult\n   - calculateConfidence(indicators: Indicator[]): number\n4. Refactor detectAll() to orchestrate detection methods:\n   const results = await Promise.all([\n     this.detectRecaptchaV2(content),\n     this.detectRecaptchaV3(content),\n     // ...\n   ]);\n5. Ensure each method is < 50 lines\n6. Add JSDoc comments to each method",
        "testStrategy": "Verify all existing detection tests still pass. Add unit tests for each extracted method. Measure cyclomatic complexity reduction. Verify no regression in detection accuracy. Test performance is maintained.",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Lazy Loading for Heavy Dependencies",
        "description": "Implement lazy loading for audio processing libraries and ML models to improve startup time",
        "details": "1. Identify heavy dependencies:\n   - Audio processing libraries (e.g., fluent-ffmpeg)\n   - ML models for detection\n   - Image processing libraries\n2. Create lazy loader service:\n   class LazyLoader {\n     private loaded = new Map<string, any>();\n     async load<T>(key: string, loader: () => Promise<T>): Promise<T> {\n       if (!this.loaded.has(key)) {\n         this.loaded.set(key, await loader());\n       }\n       return this.loaded.get(key);\n     }\n   }\n3. Update services to lazy load dependencies:\n   private async getAudioProcessor() {\n     return this.lazyLoader.load('audio', () => import('fluent-ffmpeg'));\n   }\n4. Lazy load ML models on first detection attempt\n5. Add loading state indicators\n6. Measure startup time improvement",
        "testStrategy": "Measure application startup time before and after. Verify dependencies are loaded on first use. Test that subsequent uses reuse loaded dependencies. Verify no functionality regression. Test concurrent first-time loads.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Create Troubleshooting Guide and Documentation",
        "description": "Create comprehensive troubleshooting guide with common issues, debugging tips, and performance tuning",
        "details": "1. Create docs/troubleshooting.md\n2. Document common issues:\n   - Solver timeout errors and solutions\n   - Circuit breaker activation scenarios\n   - Provider API key issues\n   - Detection false positives/negatives\n   - Performance degradation causes\n3. Add debugging section:\n   - Enable debug logging\n   - Interpret error codes\n   - Use correlation IDs for tracing\n   - Analyze metrics and traces\n4. Create performance tuning guide:\n   - Optimal configuration values\n   - Scaling considerations\n   - Cache tuning\n   - Rate limit adjustments\n5. Add error scenario examples with solutions\n6. Include code examples for common customizations\n7. Create FAQ section\n8. Add links to architecture documentation",
        "testStrategy": "Review guide with team members and external developers. Verify all examples work. Test that troubleshooting steps resolve documented issues. Ensure guide is searchable and well-organized.",
        "priority": "low",
        "dependencies": [
          19,
          21
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-17T01:03:11.457Z",
      "updated": "2025-11-17T01:07:22.554Z",
      "description": "Tasks for master context"
    }
  }
}